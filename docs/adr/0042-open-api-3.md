# Migration from Open API 2.0 to 3.0 and new codegen library selection

**User Story:** *[5022]* <!-- optional -->

*A data provider of ours, CEDAR, has just released their Open API 3.0 spec document, and we are thinking about how to
plan for this should we need to migrate.*

*We are determining if it is necessary/worth it to migrate. Some decision factors would be if CEDAR deprecates
their current 2.0 infrastructure, in which case our hand would be forced. Another factor would be if they add new
functionality to their 3.0 spec but not to their 2.0 spec.* <!-- optional -->

## Considered Alternatives

* `oapi-codegen`
* `ogen`

## Decision Outcome

* Chosen Alternative: `oapi-codegen` (for now)
* Justification: Appears to be more idiomatic Golang
* Some clunkiness in the response types, we will need a helper layer, but that is a one-time
  investment <!-- optional -->

## Pros and Cons of the Alternatives <!-- optional -->

### `oapi-codegen`

* `+` Pointers for optionality - when a field is absent, it will be `nil`
* `+` Smaller runtime (relies on builtin Go packages, such as `net/http`, instead of external libraries)
* `+` Straightforward data responses
* `+` High adoption rate
* `-` Clunky error responses (`JSON400`, `JSON401`, `JSON500`). Will be researching into if we can configure the code
  generation to handle that further upstream.

### `ogen`

* `+` Minimalist style code, less boilerplate
* `-` Similar clunky error responses as `oapi-codgen`
* `-` Larger runtime (depends more on external libraries)

__________

#### Notes:
### Preparation for CEDAR Open API 3.0 (WIP)

#### Library Selection

We selected `oapi-codegen` as our [library](https://github.com/oapi-codegen/oapi-codegen) for initial testing using
CEDAR's upcoming Open API 3.0 spec. We chose this as
our research showed it to be the most idiomatic Golang Open API 3.0 codegen library. We would have used `go-swagger`,
but `go-swagger` does not yet (and may not ever) support Open API 3.0.

For the initial testing, the client code can be generated by running `scripts/generate_cedar_clients_3`. This creates
the `pkg/cedar/core/gen/openapi_client.gen.go` file. From this file, we can get a new CEDAR client and then access all
the methods.

#### Issues so far:

- certain fields that once were defined as `time` now come through as `string` - we are waiting for this to be fixed
- the generated 3.0 code is in a slightly different form (pointers instead of values) than the 2.0 code, which means we
  need to do nil-checking/other forms of validation in the initial setup
- the Open API 3.0 spec creates return values that contain more fields than just the data, such as `JSON400`, `JSON401`,
  `JSON500`. We need to check each field for errors before attempting to access any data in the response. The goal is to
  centralize this into a single handler through the use of interfaces (TBD if possible)
- any other type issues not yet found will lead to implementation delays

#### Build out

We are experimenting with a singleton architectural pattern for the 3.0 client. This would be a departure from the
current implementation of creating the client on server start and then passing to where needed. The thought behind this
was to decouple the CEDAR client architecture and make it easier for any part of the codebase to easily acquire a CEDAR
client. This example can be found in `pkg/cedar/core/client3.go` (still WIP, but it's enough to get a picture).

Adjusting for the new return fields (`JSON400`, etc) will lead to some new code layout, and we are still determining the
best course of action to handle this.

Link to current initial build out: https://github.com/CMS-Enterprise/easi-app/tree/NOREF/testing_swagger_3
