package resolvers

import (
	"context"
	"path/filepath"

	"github.com/google/uuid"

	"github.com/cmsgov/easi-app/pkg/appcontext"
	"github.com/cmsgov/easi-app/pkg/graph/model"
	"github.com/cmsgov/easi-app/pkg/models"
	"github.com/cmsgov/easi-app/pkg/storage"
	"github.com/cmsgov/easi-app/pkg/upload"
)

const fallbackExtension = ".unknown"

// GetTRBRequestDocumentsByRequestID fetches all documents attached to the TRB request with the given ID.
func GetTRBRequestDocumentsByRequestID(ctx context.Context, store *storage.Store, s3Client *upload.S3Client, requestID uuid.UUID) ([]*models.TRBRequestDocument, error) {
	documents, err := store.GetTRBRequestDocumentsByRequestID(appcontext.ZLogger(ctx), requestID)
	if err != nil {
		return nil, err
	}

	for _, document := range documents {
		presignedURL, err := s3Client.NewGetPresignedURL(document.S3Key)
		if err != nil {
			return nil, err
		}
		document.URL = presignedURL.URL

		avStatus, err := s3Client.TagValueForKey(document.S3Key, upload.AVStatusTagName)
		if err != nil {
			return nil, err
		}

		// possible tag values come from virus scanning lambda
		// this is the same logic as in schema.resolvers.go's Documents() method for 508 documents
		if avStatus == "CLEAN" {
			document.Status = models.TRBRequestDocumentStatusAvailable
		} else if avStatus == "INFECTED" {
			document.Status = models.TRBRequestDocumentStatusUnavailable
		} else {
			document.Status = models.TRBRequestDocumentStatusPending
		}
	}

	return documents, nil
}

// CreateTRBRequestDocument uploads a document to S3, then saves its metadata to our database.
func CreateTRBRequestDocument(ctx context.Context, store *storage.Store, s3Client *upload.S3Client, input model.CreateTRBRequestDocumentInput) (*models.TRBRequestDocument, error) {
	s3Key := uuid.New().String()

	existingExtension := filepath.Ext(input.FileData.Filename)
	if existingExtension != "" {
		s3Key += existingExtension
	} else {
		s3Key += fallbackExtension
	}

	err := s3Client.UploadFile(s3Key, input.FileData.File)
	if err != nil {
		return nil, err
	}

	documentDatabaseRecord := models.TRBRequestDocument{
		TRBRequestID:       input.RequestID,
		CommonDocumentType: input.DocumentType,
		FileName:           input.FileData.Filename,
		S3Key:              s3Key,
		Bucket:             s3Client.GetBucket(),
		// Status isn't saved in database - will be fetched from S3
		// URL isn't saved in database - will be generated by querying S3
	}
	documentDatabaseRecord.CreatedBy = appcontext.Principal(ctx).ID()
	if input.OtherTypeDescription != nil {
		documentDatabaseRecord.OtherType = *input.OtherTypeDescription
	}

	return store.CreateTRBRequestDocument(appcontext.ZLogger(ctx), &documentDatabaseRecord)
}

// DeleteTRBRequestDocument deletes an existing TRBRequestDocument, given its ID.
//
// Does *not* delete the uploaded file from S3, following the example of 508/accessibility request documents.
func DeleteTRBRequestDocument(ctx context.Context, store *storage.Store, id uuid.UUID) (*models.TRBRequestDocument, error) {
	return store.DeleteTRBRequestDocument(appcontext.ZLogger(ctx), id)
}
