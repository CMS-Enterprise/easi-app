// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// GatewayCEDAR20Core20API200AuthorityToOperateGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/authorityToOperate operation.
	//
	// Retrieve Authority to Operate (ATO) information. Can filter by system ID or search using various
	// criteria including UUID, FISMA system acronym, TLC phase, PII/PHI flags, and disposition dates.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/authorityToOperate
	GatewayCEDAR20Core20API200AuthorityToOperateGet(ctx context.Context, params GatewayCEDAR20Core20API200AuthorityToOperateGetParams) (GatewayCEDAR20Core20API200AuthorityToOperateGetRes, error)
	// GatewayCEDAR20Core20API200BudgetGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/budget operation.
	//
	// Retrieve a list of budgets based on query criteria listed in the parameters section. Passing a
	// SystemId will cause the interface to return the budget(s) for just that system. Setting onlyIds to
	// true will only return the id's, whereas if not set, the response will also include projectId,
	// systemId, fundingId and funding. This interface has a limit of 5000 records.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/budget
	GatewayCEDAR20Core20API200BudgetGet(ctx context.Context, params GatewayCEDAR20Core20API200BudgetGetParams) (GatewayCEDAR20Core20API200BudgetGetRes, error)
	// GatewayCEDAR20Core20API200BudgetListDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/budget/list operation.
	//
	// Delete a list of budget items based on their ID(s).
	//
	// DELETE /gateway/CEDAR%20Core%20API/2.0.0/budget/list
	GatewayCEDAR20Core20API200BudgetListDelete(ctx context.Context, params GatewayCEDAR20Core20API200BudgetListDeleteParams) (GatewayCEDAR20Core20API200BudgetListDeleteRes, error)
	// GatewayCEDAR20Core20API200BudgetPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/budget operation.
	//
	// Add new budget(s) to the Alfabet system. This interface takes an array of one or more budgets.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/budget
	GatewayCEDAR20Core20API200BudgetPost(ctx context.Context, request *GatewayCEDAR20Core20API200BudgetPostReq) (GatewayCEDAR20Core20API200BudgetPostRes, error)
	// GatewayCEDAR20Core20API200BudgetPut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/budget operation.
	//
	// Update one or more existing budgets for a system.
	//
	// PUT /gateway/CEDAR%20Core%20API/2.0.0/budget
	GatewayCEDAR20Core20API200BudgetPut(ctx context.Context, request *GatewayCEDAR20Core20API200BudgetPutReq) (GatewayCEDAR20Core20API200BudgetPutRes, error)
	// GatewayCEDAR20Core20API200BudgetSystemCostFindGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/budgetSystemCostFind operation.
	//
	// Retrieve budget system cost information by systemId. Returns actual system costs by fiscal year.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/budgetSystemCostFind
	GatewayCEDAR20Core20API200BudgetSystemCostFindGet(ctx context.Context, params GatewayCEDAR20Core20API200BudgetSystemCostFindGetParams) (GatewayCEDAR20Core20API200BudgetSystemCostFindGetRes, error)
	// GatewayCEDAR20Core20API200ComponentPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/component operation.
	//
	// Adds a new software component and related vendor information to Alfabet.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/component
	GatewayCEDAR20Core20API200ComponentPost(ctx context.Context, request *GatewayCEDAR20Core20API200ComponentPostReq) (GatewayCEDAR20Core20API200ComponentPostRes, error)
	// GatewayCEDAR20Core20API200ContractListDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/contract/list operation.
	//
	// Delete a list of contracts based on their ID(s).
	//
	// DELETE /gateway/CEDAR%20Core%20API/2.0.0/contract/list
	GatewayCEDAR20Core20API200ContractListDelete(ctx context.Context, params GatewayCEDAR20Core20API200ContractListDeleteParams) (GatewayCEDAR20Core20API200ContractListDeleteRes, error)
	// GatewayCEDAR20Core20API200ContractListGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/contract/list operation.
	//
	// Retrieve a list of contracts based on various query criteria. Can filter by system ID, keyword
	// search, and other contract attributes.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/contract/list
	GatewayCEDAR20Core20API200ContractListGet(ctx context.Context, params GatewayCEDAR20Core20API200ContractListGetParams) (GatewayCEDAR20Core20API200ContractListGetRes, error)
	// GatewayCEDAR20Core20API200ContractPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/contract operation.
	//
	// Add new contract deliverables to the system.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/contract
	GatewayCEDAR20Core20API200ContractPost(ctx context.Context, request *GatewayCEDAR20Core20API200ContractPostReq) (GatewayCEDAR20Core20API200ContractPostRes, error)
	// GatewayCEDAR20Core20API200ContractPut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/contract operation.
	//
	// Update one or more contracts in the Alfabet system. This interface takes an array of Contract
	// documents. If the input `budgetsOnly` is set to `false`, this interface will also update any
	// associated Contract Deliverable records.
	//
	// PUT /gateway/CEDAR%20Core%20API/2.0.0/contract
	GatewayCEDAR20Core20API200ContractPut(ctx context.Context, request *GatewayCEDAR20Core20API200ContractPutReq) (GatewayCEDAR20Core20API200ContractPutRes, error)
	// GatewayCEDAR20Core20API200CostTypeListGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/costType/list operation.
	//
	// Retrieve a list of cost types. Returns the "Internal Labor" cost type as highlighted fields (id,
	// name) and all other cost types in the CostTypes array. Both application and name parameters are
	// required but not used in filtering.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/costType/list
	GatewayCEDAR20Core20API200CostTypeListGet(ctx context.Context, params GatewayCEDAR20Core20API200CostTypeListGetParams) (GatewayCEDAR20Core20API200CostTypeListGetRes, error)
	// GatewayCEDAR20Core20API200DeploymentDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
	//
	// Delete a list of deployments based on their ID(s).
	//
	// DELETE /gateway/CEDAR%20Core%20API/2.0.0/deployment
	GatewayCEDAR20Core20API200DeploymentDelete(ctx context.Context, params GatewayCEDAR20Core20API200DeploymentDeleteParams) (GatewayCEDAR20Core20API200DeploymentDeleteRes, error)
	// GatewayCEDAR20Core20API200DeploymentGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
	//
	// Retrieve a list of deployments based on query criteria (systemId, state, status and
	// deploymentType).
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/deployment
	GatewayCEDAR20Core20API200DeploymentGet(ctx context.Context, params GatewayCEDAR20Core20API200DeploymentGetParams) (GatewayCEDAR20Core20API200DeploymentGetRes, error)
	// GatewayCEDAR20Core20API200DeploymentPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
	//
	// Add one or more deployment records to the system.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/deployment
	GatewayCEDAR20Core20API200DeploymentPost(ctx context.Context, request *GatewayCEDAR20Core20API200DeploymentPostReq) (GatewayCEDAR20Core20API200DeploymentPostRes, error)
	// GatewayCEDAR20Core20API200DeploymentPut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
	//
	// Update a list of existing deployment records in Alfabet. This interface processes all deployments
	// in the request and returns detailed results for both successful and failed updates. Individual
	// deployment failures do not stop processing of other deployments in the batch. Supports batch
	// processing of up to 100 deployments per request for optimal performance.
	//
	// PUT /gateway/CEDAR%20Core%20API/2.0.0/deployment
	GatewayCEDAR20Core20API200DeploymentPut(ctx context.Context, request *GatewayCEDAR20Core20API200DeploymentPutReq) (GatewayCEDAR20Core20API200DeploymentPutRes, error)
	// GatewayCEDAR20Core20API200DomainModelLevelGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelLevel operation.
	//
	// Retrieve the hierarchy levels associated with a specific domain reference model.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelLevel
	GatewayCEDAR20Core20API200DomainModelLevelGet(ctx context.Context, params GatewayCEDAR20Core20API200DomainModelLevelGetParams) (GatewayCEDAR20Core20API200DomainModelLevelGetRes, error)
	// GatewayCEDAR20Core20API200DomainModelListGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/domainModel/list operation.
	//
	// Retrieve a list of domain model entries. The model parameter is required but not used in filtering.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/domainModel/list
	GatewayCEDAR20Core20API200DomainModelListGet(ctx context.Context, params GatewayCEDAR20Core20API200DomainModelListGetParams) (GatewayCEDAR20Core20API200DomainModelListGetRes, error)
	// GatewayCEDAR20Core20API200DomainModelNameGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelName operation.
	//
	// Retrieves a list of available domain reference models from a global configuration.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelName
	GatewayCEDAR20Core20API200DomainModelNameGet(ctx context.Context) (GatewayCEDAR20Core20API200DomainModelNameGetRes, error)
	// GatewayCEDAR20Core20API200EnumerationGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/enumeration operation.
	//
	// Retrieve a list of enumerations based on their names.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/enumeration
	GatewayCEDAR20Core20API200EnumerationGet(ctx context.Context, params GatewayCEDAR20Core20API200EnumerationGetParams) (GatewayCEDAR20Core20API200EnumerationGetRes, error)
	// GatewayCEDAR20Core20API200ExchangeGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/exchange operation.
	//
	// Exchange Find List.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/exchange
	GatewayCEDAR20Core20API200ExchangeGet(ctx context.Context, params GatewayCEDAR20Core20API200ExchangeGetParams) (GatewayCEDAR20Core20API200ExchangeGetRes, error)
	// GatewayCEDAR20Core20API200ExchangeIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/exchange/{id} operation.
	//
	// Exchange by id.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/exchange/{id}
	GatewayCEDAR20Core20API200ExchangeIDGet(ctx context.Context, params GatewayCEDAR20Core20API200ExchangeIDGetParams) (GatewayCEDAR20Core20API200ExchangeIDGetRes, error)
	// GatewayCEDAR20Core20API200ExchangePut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/exchange operation.
	//
	// Update a list of data exchange records.
	//
	// PUT /gateway/CEDAR%20Core%20API/2.0.0/exchange
	GatewayCEDAR20Core20API200ExchangePut(ctx context.Context, request *GatewayCEDAR20Core20API200ExchangePutReq) (GatewayCEDAR20Core20API200ExchangePutRes, error)
	// GatewayCEDAR20Core20API200OrganizationGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/organization operation.
	//
	// Retrieve a list of organizations based on various criteria. If no criteria are provided, an empty
	// list will be returned.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/organization
	GatewayCEDAR20Core20API200OrganizationGet(ctx context.Context, params GatewayCEDAR20Core20API200OrganizationGetParams) (GatewayCEDAR20Core20API200OrganizationGetRes, error)
	// GatewayCEDAR20Core20API200RoleGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/role operation.
	//
	// Finds a list of role assignments based on an object's ID. If objectId and roleTypeId are both
	// provided, a list of role assignments for only those specific role type IDs are returned. If roleId
	// is provided, then objectId and roleTypeId should not be provided and a specific role assignment is
	// returned.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/role
	GatewayCEDAR20Core20API200RoleGet(ctx context.Context, params GatewayCEDAR20Core20API200RoleGetParams) (GatewayCEDAR20Core20API200RoleGetRes, error)
	// GatewayCEDAR20Core20API200RoleListDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/role/list operation.
	//
	// Deletes a list of role assignments by ID from SparxEA and the local database. Takes an application
	// name and an array of role IDs.
	//
	// DELETE /gateway/CEDAR%20Core%20API/2.0.0/role/list
	GatewayCEDAR20Core20API200RoleListDelete(ctx context.Context, params GatewayCEDAR20Core20API200RoleListDeleteParams) (GatewayCEDAR20Core20API200RoleListDeleteRes, error)
	// GatewayCEDAR20Core20API200RolePost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/role operation.
	//
	// Add role assignments to a CEDAR application. This interface takes in objectId, roleTypeId AND
	// either assigneeId, assigneeUserName or assigneeOrgId are required.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/role
	GatewayCEDAR20Core20API200RolePost(ctx context.Context, request *GatewayCEDAR20Core20API200RolePostReq) (GatewayCEDAR20Core20API200RolePostRes, error)
	// GatewayCEDAR20Core20API200RoleTypeApplicationGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/role/type/{application} operation.
	//
	// Finds a list of role types available within an application. This interface takes in application.
	// The list of current roles are: AI Contact API Contact Budget Analyst Business Owner Business
	// Question Contact Contracting Officer's Representative (COR) DA Reviewer Data Center Contact ISSO
	// Government Task Lead (GTL) Project Lead QA Reviewer System Maintainer Subject Matter Expert (SME)
	// Support Staff Survey Point of Contact Technical System Issues Contact.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/role/type/{application}
	GatewayCEDAR20Core20API200RoleTypeApplicationGet(ctx context.Context, params GatewayCEDAR20Core20API200RoleTypeApplicationGetParams) (GatewayCEDAR20Core20API200RoleTypeApplicationGetRes, error)
	// GatewayCEDAR20Core20API200SoftwareProductsGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts operation.
	//
	// SoftwareProductsList.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts
	GatewayCEDAR20Core20API200SoftwareProductsGet(ctx context.Context, params GatewayCEDAR20Core20API200SoftwareProductsGetParams) (GatewayCEDAR20Core20API200SoftwareProductsGetRes, error)
	// GatewayCEDAR20Core20API200SoftwareProductsPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts operation.
	//
	// Add, update, or delete software product and API/AI-related details for a system.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts
	GatewayCEDAR20Core20API200SoftwareProductsPost(ctx context.Context, request *GatewayCEDAR20Core20API200SoftwareProductsPostReq) (GatewayCEDAR20Core20API200SoftwareProductsPostRes, error)
	// GatewayCEDAR20Core20API200StakeholderGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/stakeholder operation.
	//
	// Retrieve a list of stakeholders based on various optional criteria.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/stakeholder
	GatewayCEDAR20Core20API200StakeholderGet(ctx context.Context, params GatewayCEDAR20Core20API200StakeholderGetParams) (GatewayCEDAR20Core20API200StakeholderGetRes, error)
	// GatewayCEDAR20Core20API200SupportContactDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/supportContact operation.
	//
	// Delete a list of support contacts.
	//
	// DELETE /gateway/CEDAR%20Core%20API/2.0.0/supportContact
	GatewayCEDAR20Core20API200SupportContactDelete(ctx context.Context, params GatewayCEDAR20Core20API200SupportContactDeleteParams) (GatewayCEDAR20Core20API200SupportContactDeleteRes, error)
	// GatewayCEDAR20Core20API200SupportContactGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/supportContact operation.
	//
	// Retrieve a list of support contacts based on a system ID (application GUID).
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/supportContact
	GatewayCEDAR20Core20API200SupportContactGet(ctx context.Context, params GatewayCEDAR20Core20API200SupportContactGetParams) (GatewayCEDAR20Core20API200SupportContactGetRes, error)
	// GatewayCEDAR20Core20API200SupportContactPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/supportContact operation.
	//
	// Add or update a list of support contacts in Alfabet and the underlying database.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/supportContact
	GatewayCEDAR20Core20API200SupportContactPost(ctx context.Context, request *GatewayCEDAR20Core20API200SupportContactPostReq) (GatewayCEDAR20Core20API200SupportContactPostRes, error)
	// GatewayCEDAR20Core20API200SystemDetailIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/system/detail/{id} operation.
	//
	// System Detail by id.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/system/detail/{id}
	GatewayCEDAR20Core20API200SystemDetailIDGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemDetailIDGetParams) (GatewayCEDAR20Core20API200SystemDetailIDGetRes, error)
	// GatewayCEDAR20Core20API200SystemSummaryGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary operation.
	//
	// System Summary list.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary
	GatewayCEDAR20Core20API200SystemSummaryGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemSummaryGetParams) (GatewayCEDAR20Core20API200SystemSummaryGetRes, error)
	// GatewayCEDAR20Core20API200SystemSummaryIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary/{id} operation.
	//
	// System Summary by id.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary/{id}
	GatewayCEDAR20Core20API200SystemSummaryIDGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemSummaryIDGetParams) (GatewayCEDAR20Core20API200SystemSummaryIDGetRes, error)
	// GatewayCEDAR20Core20API200ThreatGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/threat operation.
	//
	// Threat List.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/threat
	GatewayCEDAR20Core20API200ThreatGet(ctx context.Context, params GatewayCEDAR20Core20API200ThreatGetParams) (GatewayCEDAR20Core20API200ThreatGetRes, error)
	// GatewayCEDAR20Core20API200URLIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/url/{id} operation.
	//
	// URL List.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/url/{id}
	GatewayCEDAR20Core20API200URLIDGet(ctx context.Context, params GatewayCEDAR20Core20API200URLIDGetParams) (GatewayCEDAR20Core20API200URLIDGetRes, error)
	// GatewayCEDAR20Core20API200UserGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/user operation.
	//
	// Retrieve a list of users based on various search criteria.
	//
	// GET /gateway/CEDAR%20Core%20API/2.0.0/user
	GatewayCEDAR20Core20API200UserGet(ctx context.Context, params GatewayCEDAR20Core20API200UserGetParams) (GatewayCEDAR20Core20API200UserGetRes, error)
	// GatewayCEDAR20Core20API200UserPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/user operation.
	//
	// Add a list of users to a CEDAR application, optionally creating Sparx Person records if they do
	// not exist.
	//
	// POST /gateway/CEDAR%20Core%20API/2.0.0/user
	GatewayCEDAR20Core20API200UserPost(ctx context.Context, request *GatewayCEDAR20Core20API200UserPostReq) (GatewayCEDAR20Core20API200UserPostRes, error)
	// GatewayCEDAR20Core20APIExchangePost invokes POST /gateway/CEDAR%20Core%20API/exchange operation.
	//
	// Add a list of data exchange records to the system.
	//
	// POST /gateway/CEDAR%20Core%20API/exchange
	GatewayCEDAR20Core20APIExchangePost(ctx context.Context, request *GatewayCEDAR20Core20APIExchangePostReq) (GatewayCEDAR20Core20APIExchangePostRes, error)
	// GatewayCEDARIntake10ClientIDGet invokes GET /gateway/CEDARIntake/1.0/client/{id} operation.
	//
	// Retrieve intake request data by client ID. Returns intake information filtered by client status
	// and version.
	//
	// GET /gateway/CEDARIntake/1.0/client/{id}
	GatewayCEDARIntake10ClientIDGet(ctx context.Context, params GatewayCEDARIntake10ClientIDGetParams) (GatewayCEDARIntake10ClientIDGetRes, error)
	// GatewayCEDARIntake10HealthCheckGet invokes GET /gateway/CEDARIntake/1.0/healthCheck operation.
	//
	// Health check endpoint to verify that the CEDAR Intake service is running and operational.
	//
	// GET /gateway/CEDARIntake/1.0/healthCheck
	GatewayCEDARIntake10HealthCheckGet(ctx context.Context) (GatewayCEDARIntake10HealthCheckGetRes, error)
	// GatewayCEDARIntake10IntakeCedarIDGet invokes GET /gateway/CEDARIntake/1.0/intake/cedar/{id} operation.
	//
	// Retrieve intake request data by CEDAR ID. Returns intake information for the specified CEDAR
	// intake request ID.
	//
	// GET /gateway/CEDARIntake/1.0/intake/cedar/{id}
	GatewayCEDARIntake10IntakeCedarIDGet(ctx context.Context, params GatewayCEDARIntake10IntakeCedarIDGetParams) (GatewayCEDARIntake10IntakeCedarIDGetRes, error)
	// GatewayCEDARIntake10IntakePost invokes POST /gateway/CEDARIntake/1.0/intake operation.
	//
	// Add an intake.
	//
	// POST /gateway/CEDARIntake/1.0/intake
	GatewayCEDARIntake10IntakePost(ctx context.Context, request *GatewayCEDARIntake10IntakePostReq, params GatewayCEDARIntake10IntakePostParams) (GatewayCEDARIntake10IntakePostRes, error)
	// GatewayCEDARIntake10IntakeStatusGet invokes GET /gateway/CEDARIntake/1.0/intake/status operation.
	//
	// Intake Status list.
	//
	// GET /gateway/CEDARIntake/1.0/intake/status
	GatewayCEDARIntake10IntakeStatusGet(ctx context.Context, params GatewayCEDARIntake10IntakeStatusGetParams) (GatewayCEDARIntake10IntakeStatusGetRes, error)
	// GatewayCEDARIntake10StatusCedarIDGet invokes GET /gateway/CEDARIntake/1.0/status/cedar/{id} operation.
	//
	// Retrieve intake status information by CEDAR ID. Returns status details for the specified CEDAR
	// intake request.
	//
	// GET /gateway/CEDARIntake/1.0/status/cedar/{id}
	GatewayCEDARIntake10StatusCedarIDGet(ctx context.Context, params GatewayCEDARIntake10StatusCedarIDGetParams) (GatewayCEDARIntake10StatusCedarIDGetRes, error)
	// GatewayCEDARIntake10StatusClientIDGet invokes GET /gateway/CEDARIntake/1.0/status/client/{id} operation.
	//
	// Retrieve intake status information by client ID. Returns status details for the specified client
	// intake request filtered by client status and version.
	//
	// GET /gateway/CEDARIntake/1.0/status/client/{id}
	GatewayCEDARIntake10StatusClientIDGet(ctx context.Context, params GatewayCEDARIntake10StatusClientIDGetParams) (GatewayCEDARIntake10StatusClientIDGetRes, error)
	// GatewayIntakeSchemaGet invokes GET /gateway/intake-schema operation.
	//
	// Find all intake schemas.
	//
	// GET /gateway/intake-schema
	GatewayIntakeSchemaGet(ctx context.Context) (GatewayIntakeSchemaGetRes, error)
	// GatewayIntakeSchemaIDDelete invokes DELETE /gateway/intake-schema/{id} operation.
	//
	// Delete an intake schema by name.
	//
	// DELETE /gateway/intake-schema/{id}
	GatewayIntakeSchemaIDDelete(ctx context.Context, params GatewayIntakeSchemaIDDeleteParams) (GatewayIntakeSchemaIDDeleteRes, error)
	// GatewayIntakeSchemaIDGet invokes GET /gateway/intake-schema/{id} operation.
	//
	// Find an intake schema by name.
	//
	// GET /gateway/intake-schema/{id}
	GatewayIntakeSchemaIDGet(ctx context.Context, params GatewayIntakeSchemaIDGetParams) (GatewayIntakeSchemaIDGetRes, error)
	// GatewayIntakeSchemaIDPut invokes PUT /gateway/intake-schema/{id} operation.
	//
	// Update an intake schema by name.
	//
	// PUT /gateway/intake-schema/{id}
	GatewayIntakeSchemaIDPut(ctx context.Context, request *GatewayIntakeSchemaIDPutReq, params GatewayIntakeSchemaIDPutParams) (GatewayIntakeSchemaIDPutRes, error)
	// GatewayIntakeSchemaPost invokes POST /gateway/intake-schema operation.
	//
	// Create an intake schema by name.
	//
	// POST /gateway/intake-schema
	GatewayIntakeSchemaPost(ctx context.Context, request *GatewayIntakeSchemaPostReq) (GatewayIntakeSchemaPostRes, error)
	// GatewayKeysGet invokes GET /gateway/keys operation.
	//
	// Get a list of all gateway API keys.
	//
	// GET /gateway/keys
	GatewayKeysGet(ctx context.Context) (GatewayKeysGetRes, error)
	// GatewayKeysIDDelete invokes DELETE /gateway/keys/{id} operation.
	//
	// Remove a gateway API key by ID.
	//
	// DELETE /gateway/keys/{id}
	GatewayKeysIDDelete(ctx context.Context, params GatewayKeysIDDeleteParams) (GatewayKeysIDDeleteRes, error)
	// GatewayKeysPost invokes POST /gateway/keys operation.
	//
	// Create a new gateway API key.
	//
	// POST /gateway/keys
	GatewayKeysPost(ctx context.Context) (GatewayKeysPostRes, error)
	// GatewayLDAP10AuthenticatePost invokes POST /gateway/LDAP/1.0/authenticate operation.
	//
	// Authentication endpoint that validates user credentials and returns authentication status.
	//
	// POST /gateway/LDAP/1.0/authenticate
	GatewayLDAP10AuthenticatePost(ctx context.Context, request *GatewayLDAP10AuthenticatePostReq) (GatewayLDAP10AuthenticatePostRes, error)
	// GatewayLDAP10PersonGet invokes GET /gateway/LDAP/1.0/person operation.
	//
	// Search for persons using various filter criteria. At least one search parameter must be provided.
	//
	// GET /gateway/LDAP/1.0/person
	GatewayLDAP10PersonGet(ctx context.Context, params GatewayLDAP10PersonGetParams) (GatewayLDAP10PersonGetRes, error)
	// GatewayLDAP10PersonIDGet invokes GET /gateway/LDAP/1.0/person/{id} operation.
	//
	// Get person details by ID.
	//
	// GET /gateway/LDAP/1.0/person/{id}
	GatewayLDAP10PersonIDGet(ctx context.Context, params GatewayLDAP10PersonIDGetParams) (GatewayLDAP10PersonIDGetRes, error)
	// GatewaySystem20Census20Core20API200AdminReviewerDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer operation.
	//
	// Deletes one or more System Census Reviewer records based on their ID, Username, or Type. Records
	// can be deleted individually, or a list of records can be provided in the request body.
	//
	// DELETE /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer
	GatewaySystem20Census20Core20API200AdminReviewerDelete(ctx context.Context, request *GatewaySystem20Census20Core20API200AdminReviewerDeleteReq) (GatewaySystem20Census20Core20API200AdminReviewerDeleteRes, error)
	// GatewaySystem20Census20Core20API200AdminReviewerGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/admin/reviewer operation.
	//
	// Reviewers are CMS employees responsible for verifying the accuracy and completeness of the System
	// Census Survey data each year. There are two types of reviewers, QA and DA. The list of potential
	// reviewers is returned by this endpoint and can be filtered by 'type'.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/admin/reviewer
	GatewaySystem20Census20Core20API200AdminReviewerGet(ctx context.Context, params GatewaySystem20Census20Core20API200AdminReviewerGetParams) (GatewaySystem20Census20Core20API200AdminReviewerGetRes, error)
	// GatewaySystem20Census20Core20API200AdminReviewerPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer operation.
	//
	// Add one or more System Census Reviewers.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer
	GatewaySystem20Census20Core20API200AdminReviewerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200AdminReviewerPostReq) (GatewaySystem20Census20Core20API200AdminReviewerPostRes, error)
	// GatewaySystem20Census20Core20API200BudgetAndContractsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts operation.
	//
	// Retrieve budget and contract information for a specific system.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts
	GatewaySystem20Census20Core20API200BudgetAndContractsGet(ctx context.Context, params GatewaySystem20Census20Core20API200BudgetAndContractsGetParams) (GatewaySystem20Census20Core20API200BudgetAndContractsGetRes, error)
	// GatewaySystem20Census20Core20API200BudgetAndContractsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts operation.
	//
	// Add or update budget and contract information for a system.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts
	GatewaySystem20Census20Core20API200BudgetAndContractsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200BudgetAndContractsPostReq) (GatewaySystem20Census20Core20API200BudgetAndContractsPostRes, error)
	// GatewaySystem20Census20Core20API200BusinessOwnerPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/businessOwner operation.
	//
	// Add or update business owner basic information data for a system. If an update, ID is required.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/businessOwner
	GatewaySystem20Census20Core20API200BusinessOwnerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200BusinessOwnerPostReq) (GatewaySystem20Census20Core20API200BusinessOwnerPostRes, error)
	// GatewaySystem20Census20Core20API200DataExchangeNotesDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/notes operation.
	//
	// Deletes notes associated with specific data exchange IDs. This endpoint removes notes from the
	// SYSTEM_SURVEY_EXCHANGE_NOTES table based on the provided exchange IDs. This implementation matches
	// the webmethods flow pageDataExchangeNotesDelete.
	//
	// DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/notes
	GatewaySystem20Census20Core20API200DataExchangeNotesDelete(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeNotesDeleteParams) (GatewaySystem20Census20Core20API200DataExchangeNotesDeleteRes, error)
	// GatewaySystem20Census20Core20API200DataExchangeNotesGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes operation.
	//
	// Get list of notes for a specific data exchange.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes
	GatewaySystem20Census20Core20API200DataExchangeNotesGet(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeNotesGetParams) (GatewaySystem20Census20Core20API200DataExchangeNotesGetRes, error)
	// GatewaySystem20Census20Core20API200DataExchangeNotesPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes operation.
	//
	// Add a list of notes for a data exchange.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes
	GatewaySystem20Census20Core20API200DataExchangeNotesPost(ctx context.Context, request *GatewaySystem20Census20Core20API200DataExchangeNotesPostReq) (GatewaySystem20Census20Core20API200DataExchangeNotesPostRes, error)
	// GatewaySystem20Census20Core20API200DataExchangeStatusDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status operation.
	//
	// Delete data exchange status records based on their exchange IDs.
	//
	// DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status
	GatewaySystem20Census20Core20API200DataExchangeStatusDelete(ctx context.Context, request *GatewaySystem20Census20Core20API200DataExchangeStatusDeleteReq) (GatewaySystem20Census20Core20API200DataExchangeStatusDeleteRes, error)
	// GatewaySystem20Census20Core20API200DataExchangeStatusGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status operation.
	//
	// Retrieve data exchange status information by system ID and optionally direction.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status
	GatewaySystem20Census20Core20API200DataExchangeStatusGet(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeStatusGetParams) (GatewaySystem20Census20Core20API200DataExchangeStatusGetRes, error)
	// GatewaySystem20Census20Core20API200DrmGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/drm operation.
	//
	// Retrieves all Data Reference Model (DRM) flat hierarchy data for reference purposes.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/drm
	GatewaySystem20Census20Core20API200DrmGet(ctx context.Context) (GatewaySystem20Census20Core20API200DrmGetRes, error)
	// GatewaySystem20Census20Core20API200NoteListDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/note/list operation.
	//
	// Delete a list of notes based on their ID(s).
	//
	// DELETE /gateway/System%20Census%20Core%20API/2.0.0/note/list
	GatewaySystem20Census20Core20API200NoteListDelete(ctx context.Context, params GatewaySystem20Census20Core20API200NoteListDeleteParams) (GatewaySystem20Census20Core20API200NoteListDeleteRes, error)
	// GatewaySystem20Census20Core20API200NoteListGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/note/list operation.
	//
	// Retrieve a list of notes based on a system ID and page name.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/note/list
	GatewaySystem20Census20Core20API200NoteListGet(ctx context.Context, params GatewaySystem20Census20Core20API200NoteListGetParams) (GatewaySystem20Census20Core20API200NoteListGetRes, error)
	// GatewaySystem20Census20Core20API200NotePost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/note operation.
	//
	// Add one or more notes to a system in the census database. Notes are associated with specific pages
	// within a system and can include optional email notifications to reviewers and respondents. Each
	// note is automatically timestamped upon creation.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/note
	GatewaySystem20Census20Core20API200NotePost(ctx context.Context, request *GatewaySystem20Census20Core20API200NotePostReq) (GatewaySystem20Census20Core20API200NotePostRes, error)
	// GatewaySystem20Census20Core20API200NotePut invokes PUT /gateway/System%20Census%20Core%20API/2.0.0/note operation.
	//
	// Update a specific note by its ID.
	//
	// PUT /gateway/System%20Census%20Core%20API/2.0.0/note
	GatewaySystem20Census20Core20API200NotePut(ctx context.Context, request *GatewaySystem20Census20Core20API200NotePutReq, params GatewaySystem20Census20Core20API200NotePutParams) (GatewaySystem20Census20Core20API200NotePutRes, error)
	// GatewaySystem20Census20Core20API200PageBusinessOwnerGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/businessOwner operation.
	//
	// Get business owner basic information for a system by system ID.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/businessOwner
	GatewaySystem20Census20Core20API200PageBusinessOwnerGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageBusinessOwnerGetParams) (GatewaySystem20Census20Core20API200PageBusinessOwnerGetRes, error)
	// GatewaySystem20Census20Core20API200PageDataCentersGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters operation.
	//
	// Retrieves the deployment information including the data center or cloud service provider
	// information, for given System ID.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters
	GatewaySystem20Census20Core20API200PageDataCentersGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageDataCentersGetParams) (GatewaySystem20Census20Core20API200PageDataCentersGetRes, error)
	// GatewaySystem20Census20Core20API200PageDataCentersPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters operation.
	//
	// Add, update, or delete system data center/deployment information. Supports full CRUD operations
	// for deployment relationships and system-level cloud migration settings.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters
	GatewaySystem20Census20Core20API200PageDataCentersPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataCentersPostReq) (GatewaySystem20Census20Core20API200PageDataCentersPostRes, error)
	// GatewaySystem20Census20Core20API200PageDataExchangeGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange operation.
	//
	// Retrieve data exchange information by system ID and optionally version.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange
	GatewaySystem20Census20Core20API200PageDataExchangeGet(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataExchangeGetReq, params GatewaySystem20Census20Core20API200PageDataExchangeGetParams) (GatewaySystem20Census20Core20API200PageDataExchangeGetRes, error)
	// GatewaySystem20Census20Core20API200PageDataExchangePost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange operation.
	//
	// Add or update data exchange information for a system. A data exchange can be between two CMS IT
	// systems or between a CMS system and a non-CMS stakeholder.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange
	GatewaySystem20Census20Core20API200PageDataExchangePost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataExchangePostReq) (GatewaySystem20Census20Core20API200PageDataExchangePostRes, error)
	// GatewaySystem20Census20Core20API200PageSoftwareProductsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/softwareProducts operation.
	//
	// Get software products list for a system by system ID.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/softwareProducts
	GatewaySystem20Census20Core20API200PageSoftwareProductsGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSoftwareProductsGetParams) (GatewaySystem20Census20Core20API200PageSoftwareProductsGetRes, error)
	// GatewaySystem20Census20Core20API200PageSystemDataGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemData operation.
	//
	// Retrieves system data page census information for a given system or all systems.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemData
	GatewaySystem20Census20Core20API200PageSystemDataGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSystemDataGetParams) (GatewaySystem20Census20Core20API200PageSystemDataGetRes, error)
	// GatewaySystem20Census20Core20API200PageSystemDataPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/systemData operation.
	//
	// Adds or updates system data page census information for a given system.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/page/systemData
	GatewaySystem20Census20Core20API200PageSystemDataPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageSystemDataPostReq) (GatewaySystem20Census20Core20API200PageSystemDataPostRes, error)
	// GatewaySystem20Census20Core20API200PageSystemMaintainerGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemMaintainer operation.
	//
	// Retrieve system maintainer information for a given system ID.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemMaintainer
	GatewaySystem20Census20Core20API200PageSystemMaintainerGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSystemMaintainerGetParams) (GatewaySystem20Census20Core20API200PageSystemMaintainerGetRes, error)
	// GatewaySystem20Census20Core20API200PageSystemsListGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemsList operation.
	//
	// Retrieve a list of all systems in the System Census.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemsList
	GatewaySystem20Census20Core20API200PageSystemsListGet(ctx context.Context) (GatewaySystem20Census20Core20API200PageSystemsListGetRes, error)
	// GatewaySystem20Census20Core20API200PageUrlsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/Urls operation.
	//
	// Retrieve the URLs that are used to access the system, for a given System ID.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/page/Urls
	GatewaySystem20Census20Core20API200PageUrlsGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageUrlsGetParams) (GatewaySystem20Census20Core20API200PageUrlsGetRes, error)
	// GatewaySystem20Census20Core20API200PageUrlsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/Urls operation.
	//
	// Creates, updates, or deletes URL records associated with a system.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/page/Urls
	GatewaySystem20Census20Core20API200PageUrlsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageUrlsPostReq) (GatewaySystem20Census20Core20API200PageUrlsPostRes, error)
	// GatewaySystem20Census20Core20API200PersonGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/person operation.
	//
	// Retrieve a list of persons from LDAP based on query criteria. At least one parameter must be
	// provided for the search.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/person
	GatewaySystem20Census20Core20API200PersonGet(ctx context.Context, request *GatewaySystem20Census20Core20API200PersonGetReq, params GatewaySystem20Census20Core20API200PersonGetParams) (GatewaySystem20Census20Core20API200PersonGetRes, error)
	// GatewaySystem20Census20Core20API200SoftwareProductsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/softwareProducts operation.
	//
	// Add or update software product details and system-level API/AI information.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/softwareProducts
	GatewaySystem20Census20Core20API200SoftwareProductsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SoftwareProductsPostReq) (GatewaySystem20Census20Core20API200SoftwareProductsPostRes, error)
	// GatewaySystem20Census20Core20API200StatusDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/status operation.
	//
	// Deletes one or more system status records by their IDs.
	//
	// DELETE /gateway/System%20Census%20Core%20API/2.0.0/status
	GatewaySystem20Census20Core20API200StatusDelete(ctx context.Context, params GatewaySystem20Census20Core20API200StatusDeleteParams) (GatewaySystem20Census20Core20API200StatusDeleteRes, error)
	// GatewaySystem20Census20Core20API200StatusGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/status operation.
	//
	// Retrieves system census status information for systems and pages.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/status
	GatewaySystem20Census20Core20API200StatusGet(ctx context.Context, params GatewaySystem20Census20Core20API200StatusGetParams) (GatewaySystem20Census20Core20API200StatusGetRes, error)
	// GatewaySystem20Census20Core20API200StatusPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/status operation.
	//
	// Adds or updates a list of system status records.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/status
	GatewaySystem20Census20Core20API200StatusPost(ctx context.Context, request *GatewaySystem20Census20Core20API200StatusPostReq) (GatewaySystem20Census20Core20API200StatusPostRes, error)
	// GatewaySystem20Census20Core20API200SystemAiUseGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use operation.
	//
	// Retrieves AI Use census data for a specific system by its GUID.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use
	GatewaySystem20Census20Core20API200SystemAiUseGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemAiUseGetParams) (GatewaySystem20Census20Core20API200SystemAiUseGetRes, error)
	// GatewaySystem20Census20Core20API200SystemAiUsePost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use operation.
	//
	// Updates AI Use census information for a given system.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use
	GatewaySystem20Census20Core20API200SystemAiUsePost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemAiUsePostReq) (GatewaySystem20Census20Core20API200SystemAiUsePostRes, error)
	// GatewaySystem20Census20Core20API200SystemComponentsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/systemComponents operation.
	//
	// Retrieves a list of sub-systems or components that make up the overall system. If no components
	// are found, an empty list is returned. This endpoint aligns with the Webmethods
	// `pageSystemComponentsFind` service.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/systemComponents
	GatewaySystem20Census20Core20API200SystemComponentsGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemComponentsGetParams) (GatewaySystem20Census20Core20API200SystemComponentsGetRes, error)
	// GatewaySystem20Census20Core20API200SystemComponentsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/systemComponents operation.
	//
	// Add, update or delete system components for a given system.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/systemComponents
	GatewaySystem20Census20Core20API200SystemComponentsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemComponentsPostReq) (GatewaySystem20Census20Core20API200SystemComponentsPostRes, error)
	// GatewaySystem20Census20Core20API200SystemMaintainerPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/systemMaintainer operation.
	//
	// Adds or updates system maintainer details for a given system.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/systemMaintainer
	GatewaySystem20Census20Core20API200SystemMaintainerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemMaintainerPostReq) (GatewaySystem20Census20Core20API200SystemMaintainerPostRes, error)
	// GatewaySystem20Census20Core20API200SystemPropertyGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/systemProperty operation.
	//
	// Retrieve a specific system property value for a given system ID and property name.
	//
	// GET /gateway/System%20Census%20Core%20API/2.0.0/systemProperty
	GatewaySystem20Census20Core20API200SystemPropertyGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemPropertyGetParams) (GatewaySystem20Census20Core20API200SystemPropertyGetRes, error)
	// GatewaySystem20Census20Core20API200SystemPropertyPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/systemProperty operation.
	//
	// Add or update a system property value for a given system ID and property name.
	//
	// POST /gateway/System%20Census%20Core%20API/2.0.0/systemProperty
	GatewaySystem20Census20Core20API200SystemPropertyPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemPropertyPostReq) (GatewaySystem20Census20Core20API200SystemPropertyPostRes, error)
	// GatewayTechnopedia10SoftwareExtendedGet invokes GET /gateway/Technopedia/1.0/softwareExtended operation.
	//
	// Retrieve software product information from Technopedia database. Supports multiple query modes:
	// exact match by manufacturer, product name, version, and edition (update=true), fuzzy search with
	// LIKE matching (update=false), or lookup by ID. All filter parameters are optional and can be
	// combined.
	//
	// GET /gateway/Technopedia/1.0/softwareExtended
	GatewayTechnopedia10SoftwareExtendedGet(ctx context.Context, params GatewayTechnopedia10SoftwareExtendedGetParams) (GatewayTechnopedia10SoftwareExtendedGetRes, error)
	// GatewayTechnopedia10SoftwareExtendedIDGet invokes GET /gateway/Technopedia/1.0/softwareExtended/{id} operation.
	//
	// Retrieve extended software information by ID from Technopedia database.
	//
	// GET /gateway/Technopedia/1.0/softwareExtended/{id}
	GatewayTechnopedia10SoftwareExtendedIDGet(ctx context.Context, params GatewayTechnopedia10SoftwareExtendedIDGetParams) (GatewayTechnopedia10SoftwareExtendedIDGetRes, error)
	// HealthGet invokes GET /health operation.
	//
	// Health check endpoint.
	//
	// GET /health
	HealthGet(ctx context.Context) (*HealthGetOK, error)
	// SparxIDDelete invokes DELETE /sparx/{id} operation.
	//
	// Delete SparxEA object by ID.
	//
	// DELETE /sparx/{id}
	SparxIDDelete(ctx context.Context, params SparxIDDeleteParams) (SparxIDDeleteRes, error)
	// SparxIDGet invokes GET /sparx/{id} operation.
	//
	// Get SparxEA object by ID.
	//
	// GET /sparx/{id}
	SparxIDGet(ctx context.Context, params SparxIDGetParams) (SparxIDGetRes, error)
	// SparxPost invokes POST /sparx operation.
	//
	// Create a new SparxEA object.
	//
	// POST /sparx
	SparxPost(ctx context.Context, request *SparxPostReq) (SparxPostRes, error)
	// SwaggerUIGet invokes GET /swagger-ui operation.
	//
	// Loads the Swagger UI tool.
	//
	// GET /swagger-ui
	SwaggerUIGet(ctx context.Context) (SwaggerUIGetRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// GatewayCEDAR20Core20API200AuthorityToOperateGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/authorityToOperate operation.
//
// Retrieve Authority to Operate (ATO) information. Can filter by system ID or search using various
// criteria including UUID, FISMA system acronym, TLC phase, PII/PHI flags, and disposition dates.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/authorityToOperate
func (c *Client) GatewayCEDAR20Core20API200AuthorityToOperateGet(ctx context.Context, params GatewayCEDAR20Core20API200AuthorityToOperateGetParams) (GatewayCEDAR20Core20API200AuthorityToOperateGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200AuthorityToOperateGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200AuthorityToOperateGet(ctx context.Context, params GatewayCEDAR20Core20API200AuthorityToOperateGetParams) (res GatewayCEDAR20Core20API200AuthorityToOperateGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/authorityToOperate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200AuthorityToOperateGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/authorityToOperate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SystemId.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "uuid" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "uuid",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UUID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "fismaSystemAcronym" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "fismaSystemAcronym",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FismaSystemAcronym.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tlcPhase" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tlcPhase",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TlcPhase.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "containsPersonallyIdentifiableInformation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "containsPersonallyIdentifiableInformation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ContainsPersonallyIdentifiableInformation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "isProtectedHealthInformation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "isProtectedHealthInformation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsProtectedHealthInformation.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dispositionDateAfter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dispositionDateAfter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DispositionDateAfter.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "dispositionDateBefore" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dispositionDateBefore",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DispositionDateBefore.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200AuthorityToOperateGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200AuthorityToOperateGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200AuthorityToOperateGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200BudgetGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/budget operation.
//
// Retrieve a list of budgets based on query criteria listed in the parameters section. Passing a
// SystemId will cause the interface to return the budget(s) for just that system. Setting onlyIds to
// true will only return the id's, whereas if not set, the response will also include projectId,
// systemId, fundingId and funding. This interface has a limit of 5000 records.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/budget
func (c *Client) GatewayCEDAR20Core20API200BudgetGet(ctx context.Context, params GatewayCEDAR20Core20API200BudgetGetParams) (GatewayCEDAR20Core20API200BudgetGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200BudgetGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200BudgetGet(ctx context.Context, params GatewayCEDAR20Core20API200BudgetGetParams) (res GatewayCEDAR20Core20API200BudgetGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/budget"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200BudgetGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/budget"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SystemId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "projectTitle" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "projectTitle",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectTitle.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "projectId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "projectId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "onlyIds" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "onlyIds",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OnlyIds.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "idsOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "idsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IdsOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200BudgetGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200BudgetGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200BudgetGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200BudgetListDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/budget/list operation.
//
// Delete a list of budget items based on their ID(s).
//
// DELETE /gateway/CEDAR%20Core%20API/2.0.0/budget/list
func (c *Client) GatewayCEDAR20Core20API200BudgetListDelete(ctx context.Context, params GatewayCEDAR20Core20API200BudgetListDeleteParams) (GatewayCEDAR20Core20API200BudgetListDeleteRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200BudgetListDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200BudgetListDelete(ctx context.Context, params GatewayCEDAR20Core20API200BudgetListDeleteParams) (res GatewayCEDAR20Core20API200BudgetListDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/budget/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200BudgetListDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/budget/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200BudgetListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200BudgetListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200BudgetListDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200BudgetPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/budget operation.
//
// Add new budget(s) to the Alfabet system. This interface takes an array of one or more budgets.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/budget
func (c *Client) GatewayCEDAR20Core20API200BudgetPost(ctx context.Context, request *GatewayCEDAR20Core20API200BudgetPostReq) (GatewayCEDAR20Core20API200BudgetPostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200BudgetPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200BudgetPost(ctx context.Context, request *GatewayCEDAR20Core20API200BudgetPostReq) (res GatewayCEDAR20Core20API200BudgetPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/budget"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200BudgetPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/budget"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200BudgetPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200BudgetPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200BudgetPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200BudgetPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200BudgetPut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/budget operation.
//
// Update one or more existing budgets for a system.
//
// PUT /gateway/CEDAR%20Core%20API/2.0.0/budget
func (c *Client) GatewayCEDAR20Core20API200BudgetPut(ctx context.Context, request *GatewayCEDAR20Core20API200BudgetPutReq) (GatewayCEDAR20Core20API200BudgetPutRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200BudgetPut(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200BudgetPut(ctx context.Context, request *GatewayCEDAR20Core20API200BudgetPutReq) (res GatewayCEDAR20Core20API200BudgetPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/budget"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200BudgetPutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/budget"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200BudgetPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200BudgetPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200BudgetPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200BudgetPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200BudgetSystemCostFindGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/budgetSystemCostFind operation.
//
// Retrieve budget system cost information by systemId. Returns actual system costs by fiscal year.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/budgetSystemCostFind
func (c *Client) GatewayCEDAR20Core20API200BudgetSystemCostFindGet(ctx context.Context, params GatewayCEDAR20Core20API200BudgetSystemCostFindGetParams) (GatewayCEDAR20Core20API200BudgetSystemCostFindGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200BudgetSystemCostFindGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200BudgetSystemCostFindGet(ctx context.Context, params GatewayCEDAR20Core20API200BudgetSystemCostFindGetParams) (res GatewayCEDAR20Core20API200BudgetSystemCostFindGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/budgetSystemCostFind"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200BudgetSystemCostFindGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/budgetSystemCostFind"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SystemId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200BudgetSystemCostFindGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200BudgetSystemCostFindGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200BudgetSystemCostFindGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ComponentPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/component operation.
//
// Adds a new software component and related vendor information to Alfabet.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/component
func (c *Client) GatewayCEDAR20Core20API200ComponentPost(ctx context.Context, request *GatewayCEDAR20Core20API200ComponentPostReq) (GatewayCEDAR20Core20API200ComponentPostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ComponentPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ComponentPost(ctx context.Context, request *GatewayCEDAR20Core20API200ComponentPostReq) (res GatewayCEDAR20Core20API200ComponentPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/component"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ComponentPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/component"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200ComponentPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ComponentPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ComponentPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ComponentPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ContractListDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/contract/list operation.
//
// Delete a list of contracts based on their ID(s).
//
// DELETE /gateway/CEDAR%20Core%20API/2.0.0/contract/list
func (c *Client) GatewayCEDAR20Core20API200ContractListDelete(ctx context.Context, params GatewayCEDAR20Core20API200ContractListDeleteParams) (GatewayCEDAR20Core20API200ContractListDeleteRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ContractListDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ContractListDelete(ctx context.Context, params GatewayCEDAR20Core20API200ContractListDeleteParams) (res GatewayCEDAR20Core20API200ContractListDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/contract/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ContractListDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/contract/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ContractListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ContractListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ContractListDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ContractListGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/contract/list operation.
//
// Retrieve a list of contracts based on various query criteria. Can filter by system ID, keyword
// search, and other contract attributes.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/contract/list
func (c *Client) GatewayCEDAR20Core20API200ContractListGet(ctx context.Context, params GatewayCEDAR20Core20API200ContractListGetParams) (GatewayCEDAR20Core20API200ContractListGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ContractListGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ContractListGet(ctx context.Context, params GatewayCEDAR20Core20API200ContractListGetParams) (res GatewayCEDAR20Core20API200ContractListGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/contract/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ContractListGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/contract/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SystemId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "keyword" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "keyword",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Keyword.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "POPStartDate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "POPStartDate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.POPStartDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "POPEndDate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "POPEndDate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.POPEndDate.Get(); ok {
				return e.EncodeValue(conv.DateToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "contractName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "contractName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ContractName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ContractListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ContractListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ContractListGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ContractPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/contract operation.
//
// Add new contract deliverables to the system.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/contract
func (c *Client) GatewayCEDAR20Core20API200ContractPost(ctx context.Context, request *GatewayCEDAR20Core20API200ContractPostReq) (GatewayCEDAR20Core20API200ContractPostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ContractPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ContractPost(ctx context.Context, request *GatewayCEDAR20Core20API200ContractPostReq) (res GatewayCEDAR20Core20API200ContractPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/contract"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ContractPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/contract"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200ContractPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ContractPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ContractPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ContractPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ContractPut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/contract operation.
//
// Update one or more contracts in the Alfabet system. This interface takes an array of Contract
// documents. If the input `budgetsOnly` is set to `false`, this interface will also update any
// associated Contract Deliverable records.
//
// PUT /gateway/CEDAR%20Core%20API/2.0.0/contract
func (c *Client) GatewayCEDAR20Core20API200ContractPut(ctx context.Context, request *GatewayCEDAR20Core20API200ContractPutReq) (GatewayCEDAR20Core20API200ContractPutRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ContractPut(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ContractPut(ctx context.Context, request *GatewayCEDAR20Core20API200ContractPutReq) (res GatewayCEDAR20Core20API200ContractPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/contract"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ContractPutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/contract"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200ContractPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ContractPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ContractPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ContractPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200CostTypeListGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/costType/list operation.
//
// Retrieve a list of cost types. Returns the "Internal Labor" cost type as highlighted fields (id,
// name) and all other cost types in the CostTypes array. Both application and name parameters are
// required but not used in filtering.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/costType/list
func (c *Client) GatewayCEDAR20Core20API200CostTypeListGet(ctx context.Context, params GatewayCEDAR20Core20API200CostTypeListGetParams) (GatewayCEDAR20Core20API200CostTypeListGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200CostTypeListGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200CostTypeListGet(ctx context.Context, params GatewayCEDAR20Core20API200CostTypeListGetParams) (res GatewayCEDAR20Core20API200CostTypeListGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/costType/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200CostTypeListGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/costType/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "application" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "application",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Application)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200CostTypeListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200CostTypeListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200CostTypeListGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200DeploymentDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
//
// Delete a list of deployments based on their ID(s).
//
// DELETE /gateway/CEDAR%20Core%20API/2.0.0/deployment
func (c *Client) GatewayCEDAR20Core20API200DeploymentDelete(ctx context.Context, params GatewayCEDAR20Core20API200DeploymentDeleteParams) (GatewayCEDAR20Core20API200DeploymentDeleteRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200DeploymentDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200DeploymentDelete(ctx context.Context, params GatewayCEDAR20Core20API200DeploymentDeleteParams) (res GatewayCEDAR20Core20API200DeploymentDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/deployment"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200DeploymentDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/deployment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200DeploymentDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200DeploymentDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200DeploymentDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200DeploymentGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
//
// Retrieve a list of deployments based on query criteria (systemId, state, status and
// deploymentType).
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/deployment
func (c *Client) GatewayCEDAR20Core20API200DeploymentGet(ctx context.Context, params GatewayCEDAR20Core20API200DeploymentGetParams) (GatewayCEDAR20Core20API200DeploymentGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200DeploymentGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200DeploymentGet(ctx context.Context, params GatewayCEDAR20Core20API200DeploymentGetParams) (res GatewayCEDAR20Core20API200DeploymentGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/deployment"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200DeploymentGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/deployment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "deploymentType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "deploymentType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.DeploymentType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200DeploymentGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200DeploymentGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200DeploymentGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200DeploymentPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
//
// Add one or more deployment records to the system.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/deployment
func (c *Client) GatewayCEDAR20Core20API200DeploymentPost(ctx context.Context, request *GatewayCEDAR20Core20API200DeploymentPostReq) (GatewayCEDAR20Core20API200DeploymentPostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200DeploymentPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200DeploymentPost(ctx context.Context, request *GatewayCEDAR20Core20API200DeploymentPostReq) (res GatewayCEDAR20Core20API200DeploymentPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/deployment"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200DeploymentPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/deployment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200DeploymentPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200DeploymentPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200DeploymentPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200DeploymentPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200DeploymentPut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/deployment operation.
//
// Update a list of existing deployment records in Alfabet. This interface processes all deployments
// in the request and returns detailed results for both successful and failed updates. Individual
// deployment failures do not stop processing of other deployments in the batch. Supports batch
// processing of up to 100 deployments per request for optimal performance.
//
// PUT /gateway/CEDAR%20Core%20API/2.0.0/deployment
func (c *Client) GatewayCEDAR20Core20API200DeploymentPut(ctx context.Context, request *GatewayCEDAR20Core20API200DeploymentPutReq) (GatewayCEDAR20Core20API200DeploymentPutRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200DeploymentPut(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200DeploymentPut(ctx context.Context, request *GatewayCEDAR20Core20API200DeploymentPutReq) (res GatewayCEDAR20Core20API200DeploymentPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/deployment"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200DeploymentPutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/deployment"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200DeploymentPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200DeploymentPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200DeploymentPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200DeploymentPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200DomainModelLevelGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelLevel operation.
//
// Retrieve the hierarchy levels associated with a specific domain reference model.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelLevel
func (c *Client) GatewayCEDAR20Core20API200DomainModelLevelGet(ctx context.Context, params GatewayCEDAR20Core20API200DomainModelLevelGetParams) (GatewayCEDAR20Core20API200DomainModelLevelGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200DomainModelLevelGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200DomainModelLevelGet(ctx context.Context, params GatewayCEDAR20Core20API200DomainModelLevelGetParams) (res GatewayCEDAR20Core20API200DomainModelLevelGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/domainModelLevel"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200DomainModelLevelGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/domainModelLevel"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "model" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "model",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Model))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200DomainModelLevelGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200DomainModelLevelGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200DomainModelLevelGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200DomainModelListGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/domainModel/list operation.
//
// Retrieve a list of domain model entries. The model parameter is required but not used in filtering.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/domainModel/list
func (c *Client) GatewayCEDAR20Core20API200DomainModelListGet(ctx context.Context, params GatewayCEDAR20Core20API200DomainModelListGetParams) (GatewayCEDAR20Core20API200DomainModelListGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200DomainModelListGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200DomainModelListGet(ctx context.Context, params GatewayCEDAR20Core20API200DomainModelListGetParams) (res GatewayCEDAR20Core20API200DomainModelListGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/domainModel/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200DomainModelListGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/domainModel/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "model" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "model",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Model)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200DomainModelListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200DomainModelListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200DomainModelListGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200DomainModelNameGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelName operation.
//
// Retrieves a list of available domain reference models from a global configuration.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/domainModelName
func (c *Client) GatewayCEDAR20Core20API200DomainModelNameGet(ctx context.Context) (GatewayCEDAR20Core20API200DomainModelNameGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200DomainModelNameGet(ctx)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200DomainModelNameGet(ctx context.Context) (res GatewayCEDAR20Core20API200DomainModelNameGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/domainModelName"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200DomainModelNameGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/domainModelName"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200DomainModelNameGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200DomainModelNameGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200DomainModelNameGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200EnumerationGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/enumeration operation.
//
// Retrieve a list of enumerations based on their names.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/enumeration
func (c *Client) GatewayCEDAR20Core20API200EnumerationGet(ctx context.Context, params GatewayCEDAR20Core20API200EnumerationGetParams) (GatewayCEDAR20Core20API200EnumerationGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200EnumerationGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200EnumerationGet(ctx context.Context, params GatewayCEDAR20Core20API200EnumerationGetParams) (res GatewayCEDAR20Core20API200EnumerationGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/enumeration"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200EnumerationGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/enumeration"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "application" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "application",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Application)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "names" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "names",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Names {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200EnumerationGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200EnumerationGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200EnumerationGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ExchangeGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/exchange operation.
//
// Exchange Find List.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/exchange
func (c *Client) GatewayCEDAR20Core20API200ExchangeGet(ctx context.Context, params GatewayCEDAR20Core20API200ExchangeGetParams) (GatewayCEDAR20Core20API200ExchangeGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ExchangeGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ExchangeGet(ctx context.Context, params GatewayCEDAR20Core20API200ExchangeGetParams) (res GatewayCEDAR20Core20API200ExchangeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/exchange"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ExchangeGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/exchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Direction)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ExchangeGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ExchangeGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ExchangeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ExchangeIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/exchange/{id} operation.
//
// Exchange by id.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/exchange/{id}
func (c *Client) GatewayCEDAR20Core20API200ExchangeIDGet(ctx context.Context, params GatewayCEDAR20Core20API200ExchangeIDGetParams) (GatewayCEDAR20Core20API200ExchangeIDGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ExchangeIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ExchangeIDGet(ctx context.Context, params GatewayCEDAR20Core20API200ExchangeIDGetParams) (res GatewayCEDAR20Core20API200ExchangeIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/exchange/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ExchangeIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/exchange/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ExchangeIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ExchangeIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ExchangeIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ExchangePut invokes PUT /gateway/CEDAR%20Core%20API/2.0.0/exchange operation.
//
// Update a list of data exchange records.
//
// PUT /gateway/CEDAR%20Core%20API/2.0.0/exchange
func (c *Client) GatewayCEDAR20Core20API200ExchangePut(ctx context.Context, request *GatewayCEDAR20Core20API200ExchangePutReq) (GatewayCEDAR20Core20API200ExchangePutRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ExchangePut(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ExchangePut(ctx context.Context, request *GatewayCEDAR20Core20API200ExchangePutReq) (res GatewayCEDAR20Core20API200ExchangePutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/exchange"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ExchangePutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/exchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200ExchangePutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ExchangePutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ExchangePutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ExchangePutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200OrganizationGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/organization operation.
//
// Retrieve a list of organizations based on various criteria. If no criteria are provided, an empty
// list will be returned.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/organization
func (c *Client) GatewayCEDAR20Core20API200OrganizationGet(ctx context.Context, params GatewayCEDAR20Core20API200OrganizationGetParams) (GatewayCEDAR20Core20API200OrganizationGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200OrganizationGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200OrganizationGet(ctx context.Context, params GatewayCEDAR20Core20API200OrganizationGetParams) (res GatewayCEDAR20Core20API200OrganizationGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/organization"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200OrganizationGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/organization"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "acronym" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "acronym",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Acronym.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200OrganizationGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200OrganizationGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200OrganizationGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200RoleGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/role operation.
//
// Finds a list of role assignments based on an object's ID. If objectId and roleTypeId are both
// provided, a list of role assignments for only those specific role type IDs are returned. If roleId
// is provided, then objectId and roleTypeId should not be provided and a specific role assignment is
// returned.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/role
func (c *Client) GatewayCEDAR20Core20API200RoleGet(ctx context.Context, params GatewayCEDAR20Core20API200RoleGetParams) (GatewayCEDAR20Core20API200RoleGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200RoleGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200RoleGet(ctx context.Context, params GatewayCEDAR20Core20API200RoleGetParams) (res GatewayCEDAR20Core20API200RoleGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/role"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200RoleGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/role"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "application" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "application",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Application)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "roleId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "roleId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RoleId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "objectId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "objectId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ObjectId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "roleTypeId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "roleTypeId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RoleTypeId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200RoleGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200RoleGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200RoleGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200RoleListDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/role/list operation.
//
// Deletes a list of role assignments by ID from SparxEA and the local database. Takes an application
// name and an array of role IDs.
//
// DELETE /gateway/CEDAR%20Core%20API/2.0.0/role/list
func (c *Client) GatewayCEDAR20Core20API200RoleListDelete(ctx context.Context, params GatewayCEDAR20Core20API200RoleListDeleteParams) (GatewayCEDAR20Core20API200RoleListDeleteRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200RoleListDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200RoleListDelete(ctx context.Context, params GatewayCEDAR20Core20API200RoleListDeleteParams) (res GatewayCEDAR20Core20API200RoleListDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/role/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200RoleListDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/role/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "application" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "application",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Application)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200RoleListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200RoleListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200RoleListDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200RolePost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/role operation.
//
// Add role assignments to a CEDAR application. This interface takes in objectId, roleTypeId AND
// either assigneeId, assigneeUserName or assigneeOrgId are required.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/role
func (c *Client) GatewayCEDAR20Core20API200RolePost(ctx context.Context, request *GatewayCEDAR20Core20API200RolePostReq) (GatewayCEDAR20Core20API200RolePostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200RolePost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200RolePost(ctx context.Context, request *GatewayCEDAR20Core20API200RolePostReq) (res GatewayCEDAR20Core20API200RolePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/role"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200RolePostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/role"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200RolePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200RolePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200RolePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200RolePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200RoleTypeApplicationGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/role/type/{application} operation.
//
// Finds a list of role types available within an application. This interface takes in application.
// The list of current roles are: AI Contact API Contact Budget Analyst Business Owner Business
// Question Contact Contracting Officer's Representative (COR) DA Reviewer Data Center Contact ISSO
// Government Task Lead (GTL) Project Lead QA Reviewer System Maintainer Subject Matter Expert (SME)
// Support Staff Survey Point of Contact Technical System Issues Contact.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/role/type/{application}
func (c *Client) GatewayCEDAR20Core20API200RoleTypeApplicationGet(ctx context.Context, params GatewayCEDAR20Core20API200RoleTypeApplicationGetParams) (GatewayCEDAR20Core20API200RoleTypeApplicationGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200RoleTypeApplicationGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200RoleTypeApplicationGet(ctx context.Context, params GatewayCEDAR20Core20API200RoleTypeApplicationGetParams) (res GatewayCEDAR20Core20API200RoleTypeApplicationGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/role/type/{application}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200RoleTypeApplicationGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/role/type/"
	{
		// Encode "application" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "application",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Application)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200RoleTypeApplicationGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200RoleTypeApplicationGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200RoleTypeApplicationGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SoftwareProductsGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts operation.
//
// SoftwareProductsList.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts
func (c *Client) GatewayCEDAR20Core20API200SoftwareProductsGet(ctx context.Context, params GatewayCEDAR20Core20API200SoftwareProductsGetParams) (GatewayCEDAR20Core20API200SoftwareProductsGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SoftwareProductsGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SoftwareProductsGet(ctx context.Context, params GatewayCEDAR20Core20API200SoftwareProductsGetParams) (res GatewayCEDAR20Core20API200SoftwareProductsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/softwareProducts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SoftwareProductsGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/softwareProducts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SoftwareProductsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SoftwareProductsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SoftwareProductsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SoftwareProductsPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts operation.
//
// Add, update, or delete software product and API/AI-related details for a system.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/softwareProducts
func (c *Client) GatewayCEDAR20Core20API200SoftwareProductsPost(ctx context.Context, request *GatewayCEDAR20Core20API200SoftwareProductsPostReq) (GatewayCEDAR20Core20API200SoftwareProductsPostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SoftwareProductsPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SoftwareProductsPost(ctx context.Context, request *GatewayCEDAR20Core20API200SoftwareProductsPostReq) (res GatewayCEDAR20Core20API200SoftwareProductsPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/softwareProducts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SoftwareProductsPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/softwareProducts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200SoftwareProductsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SoftwareProductsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SoftwareProductsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SoftwareProductsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200StakeholderGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/stakeholder operation.
//
// Retrieve a list of stakeholders based on various optional criteria.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/stakeholder
func (c *Client) GatewayCEDAR20Core20API200StakeholderGet(ctx context.Context, params GatewayCEDAR20Core20API200StakeholderGetParams) (GatewayCEDAR20Core20API200StakeholderGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200StakeholderGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200StakeholderGet(ctx context.Context, params GatewayCEDAR20Core20API200StakeholderGetParams) (res GatewayCEDAR20Core20API200StakeholderGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/stakeholder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200StakeholderGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/stakeholder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Version.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "idsOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "idsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IdsOnly.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200StakeholderGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200StakeholderGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200StakeholderGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SupportContactDelete invokes DELETE /gateway/CEDAR%20Core%20API/2.0.0/supportContact operation.
//
// Delete a list of support contacts.
//
// DELETE /gateway/CEDAR%20Core%20API/2.0.0/supportContact
func (c *Client) GatewayCEDAR20Core20API200SupportContactDelete(ctx context.Context, params GatewayCEDAR20Core20API200SupportContactDeleteParams) (GatewayCEDAR20Core20API200SupportContactDeleteRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SupportContactDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SupportContactDelete(ctx context.Context, params GatewayCEDAR20Core20API200SupportContactDeleteParams) (res GatewayCEDAR20Core20API200SupportContactDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/supportContact"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SupportContactDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/supportContact"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.UUIDToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SupportContactDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SupportContactDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SupportContactDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SupportContactGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/supportContact operation.
//
// Retrieve a list of support contacts based on a system ID (application GUID).
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/supportContact
func (c *Client) GatewayCEDAR20Core20API200SupportContactGet(ctx context.Context, params GatewayCEDAR20Core20API200SupportContactGetParams) (GatewayCEDAR20Core20API200SupportContactGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SupportContactGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SupportContactGet(ctx context.Context, params GatewayCEDAR20Core20API200SupportContactGetParams) (res GatewayCEDAR20Core20API200SupportContactGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/supportContact"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SupportContactGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/supportContact"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "application" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "application",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Application))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SupportContactGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SupportContactGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SupportContactGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SupportContactPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/supportContact operation.
//
// Add or update a list of support contacts in Alfabet and the underlying database.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/supportContact
func (c *Client) GatewayCEDAR20Core20API200SupportContactPost(ctx context.Context, request *GatewayCEDAR20Core20API200SupportContactPostReq) (GatewayCEDAR20Core20API200SupportContactPostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SupportContactPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SupportContactPost(ctx context.Context, request *GatewayCEDAR20Core20API200SupportContactPostReq) (res GatewayCEDAR20Core20API200SupportContactPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/supportContact"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SupportContactPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/supportContact"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200SupportContactPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SupportContactPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SupportContactPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SupportContactPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SystemDetailIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/system/detail/{id} operation.
//
// System Detail by id.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/system/detail/{id}
func (c *Client) GatewayCEDAR20Core20API200SystemDetailIDGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemDetailIDGetParams) (GatewayCEDAR20Core20API200SystemDetailIDGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SystemDetailIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SystemDetailIDGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemDetailIDGetParams) (res GatewayCEDAR20Core20API200SystemDetailIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/system/detail/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SystemDetailIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/system/detail/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SystemDetailIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SystemDetailIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SystemDetailIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SystemSummaryGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary operation.
//
// System Summary list.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary
func (c *Client) GatewayCEDAR20Core20API200SystemSummaryGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemSummaryGetParams) (GatewayCEDAR20Core20API200SystemSummaryGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SystemSummaryGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SystemSummaryGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemSummaryGetParams) (res GatewayCEDAR20Core20API200SystemSummaryGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/system/summary"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SystemSummaryGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/system/summary"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Version.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "includeInSurvey" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "includeInSurvey",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeInSurvey.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "idsOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "idsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IdsOnly.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "belongsTo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "belongsTo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.BelongsTo.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "userName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "userName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UserName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "roleType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "roleType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RoleType.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SystemSummaryGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SystemSummaryGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SystemSummaryGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200SystemSummaryIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary/{id} operation.
//
// System Summary by id.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/system/summary/{id}
func (c *Client) GatewayCEDAR20Core20API200SystemSummaryIDGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemSummaryIDGetParams) (GatewayCEDAR20Core20API200SystemSummaryIDGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200SystemSummaryIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200SystemSummaryIDGet(ctx context.Context, params GatewayCEDAR20Core20API200SystemSummaryIDGetParams) (res GatewayCEDAR20Core20API200SystemSummaryIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/system/summary/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200SystemSummaryIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/system/summary/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200SystemSummaryIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200SystemSummaryIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200SystemSummaryIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200ThreatGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/threat operation.
//
// Threat List.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/threat
func (c *Client) GatewayCEDAR20Core20API200ThreatGet(ctx context.Context, params GatewayCEDAR20Core20API200ThreatGetParams) (GatewayCEDAR20Core20API200ThreatGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200ThreatGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200ThreatGet(ctx context.Context, params GatewayCEDAR20Core20API200ThreatGetParams) (res GatewayCEDAR20Core20API200ThreatGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/threat"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200ThreatGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/threat"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200ThreatGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200ThreatGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200ThreatGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200URLIDGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/url/{id} operation.
//
// URL List.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/url/{id}
func (c *Client) GatewayCEDAR20Core20API200URLIDGet(ctx context.Context, params GatewayCEDAR20Core20API200URLIDGetParams) (GatewayCEDAR20Core20API200URLIDGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200URLIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200URLIDGet(ctx context.Context, params GatewayCEDAR20Core20API200URLIDGetParams) (res GatewayCEDAR20Core20API200URLIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/url/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200URLIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/url/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200URLIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200URLIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200URLIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200UserGet invokes GET /gateway/CEDAR%20Core%20API/2.0.0/user operation.
//
// Retrieve a list of users based on various search criteria.
//
// GET /gateway/CEDAR%20Core%20API/2.0.0/user
func (c *Client) GatewayCEDAR20Core20API200UserGet(ctx context.Context, params GatewayCEDAR20Core20API200UserGetParams) (GatewayCEDAR20Core20API200UserGetRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200UserGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200UserGet(ctx context.Context, params GatewayCEDAR20Core20API200UserGetParams) (res GatewayCEDAR20Core20API200UserGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/user"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200UserGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/user"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "application" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "application",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Application)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "userName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "userName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UserName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "firstName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "firstName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FirstName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "lastName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "lastName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LastName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Phone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "email" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Email.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200UserGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200UserGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200UserGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20API200UserPost invokes POST /gateway/CEDAR%20Core%20API/2.0.0/user operation.
//
// Add a list of users to a CEDAR application, optionally creating Sparx Person records if they do
// not exist.
//
// POST /gateway/CEDAR%20Core%20API/2.0.0/user
func (c *Client) GatewayCEDAR20Core20API200UserPost(ctx context.Context, request *GatewayCEDAR20Core20API200UserPostReq) (GatewayCEDAR20Core20API200UserPostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20API200UserPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20API200UserPost(ctx context.Context, request *GatewayCEDAR20Core20API200UserPostReq) (res GatewayCEDAR20Core20API200UserPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/2.0.0/user"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20API200UserPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/2.0.0/user"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20API200UserPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20API200UserPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20API200UserPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20API200UserPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDAR20Core20APIExchangePost invokes POST /gateway/CEDAR%20Core%20API/exchange operation.
//
// Add a list of data exchange records to the system.
//
// POST /gateway/CEDAR%20Core%20API/exchange
func (c *Client) GatewayCEDAR20Core20APIExchangePost(ctx context.Context, request *GatewayCEDAR20Core20APIExchangePostReq) (GatewayCEDAR20Core20APIExchangePostRes, error) {
	res, err := c.sendGatewayCEDAR20Core20APIExchangePost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayCEDAR20Core20APIExchangePost(ctx context.Context, request *GatewayCEDAR20Core20APIExchangePostReq) (res GatewayCEDAR20Core20APIExchangePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDAR%20Core%20API/exchange"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDAR20Core20APIExchangePostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDAR%20Core%20API/exchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDAR20Core20APIExchangePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDAR20Core20APIExchangePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDAR20Core20APIExchangePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDAR20Core20APIExchangePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDARIntake10ClientIDGet invokes GET /gateway/CEDARIntake/1.0/client/{id} operation.
//
// Retrieve intake request data by client ID. Returns intake information filtered by client status
// and version.
//
// GET /gateway/CEDARIntake/1.0/client/{id}
func (c *Client) GatewayCEDARIntake10ClientIDGet(ctx context.Context, params GatewayCEDARIntake10ClientIDGetParams) (GatewayCEDARIntake10ClientIDGetRes, error) {
	res, err := c.sendGatewayCEDARIntake10ClientIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDARIntake10ClientIDGet(ctx context.Context, params GatewayCEDARIntake10ClientIDGetParams) (res GatewayCEDARIntake10ClientIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDARIntake/1.0/client/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDARIntake10ClientIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDARIntake/1.0/client/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "clientStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "clientStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ClientStatus))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "CLIENT_NAME",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.CLIENTNAME))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDARIntake10ClientIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDARIntake10ClientIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDARIntake10ClientIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDARIntake10HealthCheckGet invokes GET /gateway/CEDARIntake/1.0/healthCheck operation.
//
// Health check endpoint to verify that the CEDAR Intake service is running and operational.
//
// GET /gateway/CEDARIntake/1.0/healthCheck
func (c *Client) GatewayCEDARIntake10HealthCheckGet(ctx context.Context) (GatewayCEDARIntake10HealthCheckGetRes, error) {
	res, err := c.sendGatewayCEDARIntake10HealthCheckGet(ctx)
	return res, err
}

func (c *Client) sendGatewayCEDARIntake10HealthCheckGet(ctx context.Context) (res GatewayCEDARIntake10HealthCheckGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDARIntake/1.0/healthCheck"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDARIntake10HealthCheckGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDARIntake/1.0/healthCheck"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDARIntake10HealthCheckGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDARIntake10HealthCheckGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDARIntake10HealthCheckGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDARIntake10IntakeCedarIDGet invokes GET /gateway/CEDARIntake/1.0/intake/cedar/{id} operation.
//
// Retrieve intake request data by CEDAR ID. Returns intake information for the specified CEDAR
// intake request ID.
//
// GET /gateway/CEDARIntake/1.0/intake/cedar/{id}
func (c *Client) GatewayCEDARIntake10IntakeCedarIDGet(ctx context.Context, params GatewayCEDARIntake10IntakeCedarIDGetParams) (GatewayCEDARIntake10IntakeCedarIDGetRes, error) {
	res, err := c.sendGatewayCEDARIntake10IntakeCedarIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDARIntake10IntakeCedarIDGet(ctx context.Context, params GatewayCEDARIntake10IntakeCedarIDGetParams) (res GatewayCEDARIntake10IntakeCedarIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDARIntake/1.0/intake/cedar/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDARIntake10IntakeCedarIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDARIntake/1.0/intake/cedar/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "CLIENT_NAME",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.CLIENTNAME))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDARIntake10IntakeCedarIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDARIntake10IntakeCedarIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDARIntake10IntakeCedarIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDARIntake10IntakePost invokes POST /gateway/CEDARIntake/1.0/intake operation.
//
// Add an intake.
//
// POST /gateway/CEDARIntake/1.0/intake
func (c *Client) GatewayCEDARIntake10IntakePost(ctx context.Context, request *GatewayCEDARIntake10IntakePostReq, params GatewayCEDARIntake10IntakePostParams) (GatewayCEDARIntake10IntakePostRes, error) {
	res, err := c.sendGatewayCEDARIntake10IntakePost(ctx, request, params)
	return res, err
}

func (c *Client) sendGatewayCEDARIntake10IntakePost(ctx context.Context, request *GatewayCEDARIntake10IntakePostReq, params GatewayCEDARIntake10IntakePostParams) (res GatewayCEDARIntake10IntakePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/CEDARIntake/1.0/intake"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDARIntake10IntakePostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDARIntake/1.0/intake"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "validatePayload" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "validatePayload",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ValidatePayload.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayCEDARIntake10IntakePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "CLIENT_NAME",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.CLIENTNAME))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDARIntake10IntakePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDARIntake10IntakePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDARIntake10IntakePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDARIntake10IntakeStatusGet invokes GET /gateway/CEDARIntake/1.0/intake/status operation.
//
// Intake Status list.
//
// GET /gateway/CEDARIntake/1.0/intake/status
func (c *Client) GatewayCEDARIntake10IntakeStatusGet(ctx context.Context, params GatewayCEDARIntake10IntakeStatusGetParams) (GatewayCEDARIntake10IntakeStatusGetRes, error) {
	res, err := c.sendGatewayCEDARIntake10IntakeStatusGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDARIntake10IntakeStatusGet(ctx context.Context, params GatewayCEDARIntake10IntakeStatusGetParams) (res GatewayCEDARIntake10IntakeStatusGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDARIntake/1.0/intake/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDARIntake10IntakeStatusGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/CEDARIntake/1.0/intake/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "cedarStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cedarStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.CedarStatus)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "clientCreatedStartDate" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "clientCreatedStartDate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ClientCreatedStartDate.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageNumber" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageNumber",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageNumber.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDARIntake10IntakeStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDARIntake10IntakeStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDARIntake10IntakeStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDARIntake10StatusCedarIDGet invokes GET /gateway/CEDARIntake/1.0/status/cedar/{id} operation.
//
// Retrieve intake status information by CEDAR ID. Returns status details for the specified CEDAR
// intake request.
//
// GET /gateway/CEDARIntake/1.0/status/cedar/{id}
func (c *Client) GatewayCEDARIntake10StatusCedarIDGet(ctx context.Context, params GatewayCEDARIntake10StatusCedarIDGetParams) (GatewayCEDARIntake10StatusCedarIDGetRes, error) {
	res, err := c.sendGatewayCEDARIntake10StatusCedarIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDARIntake10StatusCedarIDGet(ctx context.Context, params GatewayCEDARIntake10StatusCedarIDGetParams) (res GatewayCEDARIntake10StatusCedarIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDARIntake/1.0/status/cedar/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDARIntake10StatusCedarIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDARIntake/1.0/status/cedar/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "CLIENT_NAME",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.CLIENTNAME))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDARIntake10StatusCedarIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDARIntake10StatusCedarIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDARIntake10StatusCedarIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayCEDARIntake10StatusClientIDGet invokes GET /gateway/CEDARIntake/1.0/status/client/{id} operation.
//
// Retrieve intake status information by client ID. Returns status details for the specified client
// intake request filtered by client status and version.
//
// GET /gateway/CEDARIntake/1.0/status/client/{id}
func (c *Client) GatewayCEDARIntake10StatusClientIDGet(ctx context.Context, params GatewayCEDARIntake10StatusClientIDGetParams) (GatewayCEDARIntake10StatusClientIDGetRes, error) {
	res, err := c.sendGatewayCEDARIntake10StatusClientIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayCEDARIntake10StatusClientIDGet(ctx context.Context, params GatewayCEDARIntake10StatusClientIDGetParams) (res GatewayCEDARIntake10StatusClientIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/CEDARIntake/1.0/status/client/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayCEDARIntake10StatusClientIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/CEDARIntake/1.0/status/client/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "clientStatus" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "clientStatus",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ClientStatus))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "EncodeHeaderParams"
	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "CLIENT_NAME",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.CLIENTNAME))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayCEDARIntake10StatusClientIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayCEDARIntake10StatusClientIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayCEDARIntake10StatusClientIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayIntakeSchemaGet invokes GET /gateway/intake-schema operation.
//
// Find all intake schemas.
//
// GET /gateway/intake-schema
func (c *Client) GatewayIntakeSchemaGet(ctx context.Context) (GatewayIntakeSchemaGetRes, error) {
	res, err := c.sendGatewayIntakeSchemaGet(ctx)
	return res, err
}

func (c *Client) sendGatewayIntakeSchemaGet(ctx context.Context) (res GatewayIntakeSchemaGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/intake-schema"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayIntakeSchemaGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/intake-schema"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayIntakeSchemaGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayIntakeSchemaGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayIntakeSchemaGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayIntakeSchemaIDDelete invokes DELETE /gateway/intake-schema/{id} operation.
//
// Delete an intake schema by name.
//
// DELETE /gateway/intake-schema/{id}
func (c *Client) GatewayIntakeSchemaIDDelete(ctx context.Context, params GatewayIntakeSchemaIDDeleteParams) (GatewayIntakeSchemaIDDeleteRes, error) {
	res, err := c.sendGatewayIntakeSchemaIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewayIntakeSchemaIDDelete(ctx context.Context, params GatewayIntakeSchemaIDDeleteParams) (res GatewayIntakeSchemaIDDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/intake-schema/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayIntakeSchemaIDDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/intake-schema/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayIntakeSchemaIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayIntakeSchemaIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayIntakeSchemaIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayIntakeSchemaIDGet invokes GET /gateway/intake-schema/{id} operation.
//
// Find an intake schema by name.
//
// GET /gateway/intake-schema/{id}
func (c *Client) GatewayIntakeSchemaIDGet(ctx context.Context, params GatewayIntakeSchemaIDGetParams) (GatewayIntakeSchemaIDGetRes, error) {
	res, err := c.sendGatewayIntakeSchemaIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayIntakeSchemaIDGet(ctx context.Context, params GatewayIntakeSchemaIDGetParams) (res GatewayIntakeSchemaIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/intake-schema/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayIntakeSchemaIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/intake-schema/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayIntakeSchemaIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayIntakeSchemaIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayIntakeSchemaIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayIntakeSchemaIDPut invokes PUT /gateway/intake-schema/{id} operation.
//
// Update an intake schema by name.
//
// PUT /gateway/intake-schema/{id}
func (c *Client) GatewayIntakeSchemaIDPut(ctx context.Context, request *GatewayIntakeSchemaIDPutReq, params GatewayIntakeSchemaIDPutParams) (GatewayIntakeSchemaIDPutRes, error) {
	res, err := c.sendGatewayIntakeSchemaIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendGatewayIntakeSchemaIDPut(ctx context.Context, request *GatewayIntakeSchemaIDPutReq, params GatewayIntakeSchemaIDPutParams) (res GatewayIntakeSchemaIDPutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/gateway/intake-schema/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayIntakeSchemaIDPutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/intake-schema/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayIntakeSchemaIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayIntakeSchemaIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayIntakeSchemaIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayIntakeSchemaIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayIntakeSchemaPost invokes POST /gateway/intake-schema operation.
//
// Create an intake schema by name.
//
// POST /gateway/intake-schema
func (c *Client) GatewayIntakeSchemaPost(ctx context.Context, request *GatewayIntakeSchemaPostReq) (GatewayIntakeSchemaPostRes, error) {
	res, err := c.sendGatewayIntakeSchemaPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayIntakeSchemaPost(ctx context.Context, request *GatewayIntakeSchemaPostReq) (res GatewayIntakeSchemaPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/intake-schema"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayIntakeSchemaPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/intake-schema"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayIntakeSchemaPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayIntakeSchemaPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayIntakeSchemaPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayIntakeSchemaPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayKeysGet invokes GET /gateway/keys operation.
//
// Get a list of all gateway API keys.
//
// GET /gateway/keys
func (c *Client) GatewayKeysGet(ctx context.Context) (GatewayKeysGetRes, error) {
	res, err := c.sendGatewayKeysGet(ctx)
	return res, err
}

func (c *Client) sendGatewayKeysGet(ctx context.Context) (res GatewayKeysGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/keys"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayKeysGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayKeysGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayKeysGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayKeysIDDelete invokes DELETE /gateway/keys/{id} operation.
//
// Remove a gateway API key by ID.
//
// DELETE /gateway/keys/{id}
func (c *Client) GatewayKeysIDDelete(ctx context.Context, params GatewayKeysIDDeleteParams) (GatewayKeysIDDeleteRes, error) {
	res, err := c.sendGatewayKeysIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewayKeysIDDelete(ctx context.Context, params GatewayKeysIDDeleteParams) (res GatewayKeysIDDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/keys/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayKeysIDDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayKeysIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayKeysIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayKeysPost invokes POST /gateway/keys operation.
//
// Create a new gateway API key.
//
// POST /gateway/keys
func (c *Client) GatewayKeysPost(ctx context.Context) (GatewayKeysPostRes, error) {
	res, err := c.sendGatewayKeysPost(ctx)
	return res, err
}

func (c *Client) sendGatewayKeysPost(ctx context.Context) (res GatewayKeysPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/keys"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayKeysPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/keys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayKeysPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayKeysPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayLDAP10AuthenticatePost invokes POST /gateway/LDAP/1.0/authenticate operation.
//
// Authentication endpoint that validates user credentials and returns authentication status.
//
// POST /gateway/LDAP/1.0/authenticate
func (c *Client) GatewayLDAP10AuthenticatePost(ctx context.Context, request *GatewayLDAP10AuthenticatePostReq) (GatewayLDAP10AuthenticatePostRes, error) {
	res, err := c.sendGatewayLDAP10AuthenticatePost(ctx, request)
	return res, err
}

func (c *Client) sendGatewayLDAP10AuthenticatePost(ctx context.Context, request *GatewayLDAP10AuthenticatePostReq) (res GatewayLDAP10AuthenticatePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/LDAP/1.0/authenticate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayLDAP10AuthenticatePostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/LDAP/1.0/authenticate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewayLDAP10AuthenticatePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayLDAP10AuthenticatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayLDAP10PersonGet invokes GET /gateway/LDAP/1.0/person operation.
//
// Search for persons using various filter criteria. At least one search parameter must be provided.
//
// GET /gateway/LDAP/1.0/person
func (c *Client) GatewayLDAP10PersonGet(ctx context.Context, params GatewayLDAP10PersonGetParams) (GatewayLDAP10PersonGetRes, error) {
	res, err := c.sendGatewayLDAP10PersonGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayLDAP10PersonGet(ctx context.Context, params GatewayLDAP10PersonGetParams) (res GatewayLDAP10PersonGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/LDAP/1.0/person"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayLDAP10PersonGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/LDAP/1.0/person"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "first_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "first_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FirstName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "last_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "last_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LastName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "commonName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "commonName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CommonName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "email" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Email.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "telephone" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "telephone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Telephone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayLDAP10PersonGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayLDAP10PersonGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayLDAP10PersonGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayLDAP10PersonIDGet invokes GET /gateway/LDAP/1.0/person/{id} operation.
//
// Get person details by ID.
//
// GET /gateway/LDAP/1.0/person/{id}
func (c *Client) GatewayLDAP10PersonIDGet(ctx context.Context, params GatewayLDAP10PersonIDGetParams) (GatewayLDAP10PersonIDGetRes, error) {
	res, err := c.sendGatewayLDAP10PersonIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayLDAP10PersonIDGet(ctx context.Context, params GatewayLDAP10PersonIDGetParams) (res GatewayLDAP10PersonIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/LDAP/1.0/person/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayLDAP10PersonIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/LDAP/1.0/person/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayLDAP10PersonIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayLDAP10PersonIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayLDAP10PersonIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200AdminReviewerDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer operation.
//
// Deletes one or more System Census Reviewer records based on their ID, Username, or Type. Records
// can be deleted individually, or a list of records can be provided in the request body.
//
// DELETE /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer
func (c *Client) GatewaySystem20Census20Core20API200AdminReviewerDelete(ctx context.Context, request *GatewaySystem20Census20Core20API200AdminReviewerDeleteReq) (GatewaySystem20Census20Core20API200AdminReviewerDeleteRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200AdminReviewerDelete(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200AdminReviewerDelete(ctx context.Context, request *GatewaySystem20Census20Core20API200AdminReviewerDeleteReq) (res GatewaySystem20Census20Core20API200AdminReviewerDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/adminReviewer"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200AdminReviewerDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/adminReviewer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200AdminReviewerDeleteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200AdminReviewerDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200AdminReviewerDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200AdminReviewerDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200AdminReviewerGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/admin/reviewer operation.
//
// Reviewers are CMS employees responsible for verifying the accuracy and completeness of the System
// Census Survey data each year. There are two types of reviewers, QA and DA. The list of potential
// reviewers is returned by this endpoint and can be filtered by 'type'.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/admin/reviewer
func (c *Client) GatewaySystem20Census20Core20API200AdminReviewerGet(ctx context.Context, params GatewaySystem20Census20Core20API200AdminReviewerGetParams) (GatewaySystem20Census20Core20API200AdminReviewerGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200AdminReviewerGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200AdminReviewerGet(ctx context.Context, params GatewaySystem20Census20Core20API200AdminReviewerGetParams) (res GatewaySystem20Census20Core20API200AdminReviewerGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/admin/reviewer"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200AdminReviewerGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/admin/reviewer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200AdminReviewerGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200AdminReviewerGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200AdminReviewerGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200AdminReviewerPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer operation.
//
// Add one or more System Census Reviewers.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/adminReviewer
func (c *Client) GatewaySystem20Census20Core20API200AdminReviewerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200AdminReviewerPostReq) (GatewaySystem20Census20Core20API200AdminReviewerPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200AdminReviewerPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200AdminReviewerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200AdminReviewerPostReq) (res GatewaySystem20Census20Core20API200AdminReviewerPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/adminReviewer"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200AdminReviewerPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/adminReviewer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200AdminReviewerPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200AdminReviewerPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200AdminReviewerPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200AdminReviewerPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200BudgetAndContractsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts operation.
//
// Retrieve budget and contract information for a specific system.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts
func (c *Client) GatewaySystem20Census20Core20API200BudgetAndContractsGet(ctx context.Context, params GatewaySystem20Census20Core20API200BudgetAndContractsGetParams) (GatewaySystem20Census20Core20API200BudgetAndContractsGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200BudgetAndContractsGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200BudgetAndContractsGet(ctx context.Context, params GatewaySystem20Census20Core20API200BudgetAndContractsGetParams) (res GatewaySystem20Census20Core20API200BudgetAndContractsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200BudgetAndContractsGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.UUIDToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200BudgetAndContractsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200BudgetAndContractsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200BudgetAndContractsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200BudgetAndContractsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts operation.
//
// Add or update budget and contract information for a system.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts
func (c *Client) GatewaySystem20Census20Core20API200BudgetAndContractsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200BudgetAndContractsPostReq) (GatewaySystem20Census20Core20API200BudgetAndContractsPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200BudgetAndContractsPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200BudgetAndContractsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200BudgetAndContractsPostReq) (res GatewaySystem20Census20Core20API200BudgetAndContractsPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200BudgetAndContractsPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/budgetAndContracts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200BudgetAndContractsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200BudgetAndContractsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200BudgetAndContractsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200BudgetAndContractsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200BusinessOwnerPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/businessOwner operation.
//
// Add or update business owner basic information data for a system. If an update, ID is required.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/businessOwner
func (c *Client) GatewaySystem20Census20Core20API200BusinessOwnerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200BusinessOwnerPostReq) (GatewaySystem20Census20Core20API200BusinessOwnerPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200BusinessOwnerPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200BusinessOwnerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200BusinessOwnerPostReq) (res GatewaySystem20Census20Core20API200BusinessOwnerPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/businessOwner"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200BusinessOwnerPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/businessOwner"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200BusinessOwnerPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200BusinessOwnerPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200BusinessOwnerPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200BusinessOwnerPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200DataExchangeNotesDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/notes operation.
//
// Deletes notes associated with specific data exchange IDs. This endpoint removes notes from the
// SYSTEM_SURVEY_EXCHANGE_NOTES table based on the provided exchange IDs. This implementation matches
// the webmethods flow pageDataExchangeNotesDelete.
//
// DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/notes
func (c *Client) GatewaySystem20Census20Core20API200DataExchangeNotesDelete(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeNotesDeleteParams) (GatewaySystem20Census20Core20API200DataExchangeNotesDeleteRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200DataExchangeNotesDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200DataExchangeNotesDelete(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeNotesDeleteParams) (res GatewaySystem20Census20Core20API200DataExchangeNotesDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/dataExchange/notes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/dataExchange/notes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200DataExchangeNotesDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200DataExchangeNotesGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes operation.
//
// Get list of notes for a specific data exchange.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes
func (c *Client) GatewaySystem20Census20Core20API200DataExchangeNotesGet(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeNotesGetParams) (GatewaySystem20Census20Core20API200DataExchangeNotesGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200DataExchangeNotesGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200DataExchangeNotesGet(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeNotesGetParams) (res GatewaySystem20Census20Core20API200DataExchangeNotesGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "exchangeId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exchangeId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ExchangeId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200DataExchangeNotesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200DataExchangeNotesPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes operation.
//
// Add a list of notes for a data exchange.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes
func (c *Client) GatewaySystem20Census20Core20API200DataExchangeNotesPost(ctx context.Context, request *GatewaySystem20Census20Core20API200DataExchangeNotesPostReq) (GatewaySystem20Census20Core20API200DataExchangeNotesPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200DataExchangeNotesPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200DataExchangeNotesPost(ctx context.Context, request *GatewaySystem20Census20Core20API200DataExchangeNotesPostReq) (res GatewaySystem20Census20Core20API200DataExchangeNotesPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/dataExchangeNotes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200DataExchangeNotesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200DataExchangeNotesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200DataExchangeNotesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200DataExchangeStatusDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status operation.
//
// Delete data exchange status records based on their exchange IDs.
//
// DELETE /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status
func (c *Client) GatewaySystem20Census20Core20API200DataExchangeStatusDelete(ctx context.Context, request *GatewaySystem20Census20Core20API200DataExchangeStatusDeleteReq) (GatewaySystem20Census20Core20API200DataExchangeStatusDeleteRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200DataExchangeStatusDelete(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200DataExchangeStatusDelete(ctx context.Context, request *GatewaySystem20Census20Core20API200DataExchangeStatusDeleteReq) (res GatewaySystem20Census20Core20API200DataExchangeStatusDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200DataExchangeStatusDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200DataExchangeStatusDeleteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200DataExchangeStatusDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200DataExchangeStatusDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200DataExchangeStatusDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200DataExchangeStatusGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status operation.
//
// Retrieve data exchange status information by system ID and optionally direction.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status
func (c *Client) GatewaySystem20Census20Core20API200DataExchangeStatusGet(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeStatusGetParams) (GatewaySystem20Census20Core20API200DataExchangeStatusGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200DataExchangeStatusGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200DataExchangeStatusGet(ctx context.Context, params GatewaySystem20Census20Core20API200DataExchangeStatusGetParams) (res GatewaySystem20Census20Core20API200DataExchangeStatusGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200DataExchangeStatusGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/dataExchange/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.UUIDToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "direction" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "direction",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Direction.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200DataExchangeStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200DataExchangeStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200DataExchangeStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200DrmGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/drm operation.
//
// Retrieves all Data Reference Model (DRM) flat hierarchy data for reference purposes.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/drm
func (c *Client) GatewaySystem20Census20Core20API200DrmGet(ctx context.Context) (GatewaySystem20Census20Core20API200DrmGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200DrmGet(ctx)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200DrmGet(ctx context.Context) (res GatewaySystem20Census20Core20API200DrmGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/drm"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200DrmGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/drm"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200DrmGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200DrmGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200DrmGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200NoteListDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/note/list operation.
//
// Delete a list of notes based on their ID(s).
//
// DELETE /gateway/System%20Census%20Core%20API/2.0.0/note/list
func (c *Client) GatewaySystem20Census20Core20API200NoteListDelete(ctx context.Context, params GatewaySystem20Census20Core20API200NoteListDeleteParams) (GatewaySystem20Census20Core20API200NoteListDeleteRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200NoteListDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200NoteListDelete(ctx context.Context, params GatewaySystem20Census20Core20API200NoteListDeleteParams) (res GatewaySystem20Census20Core20API200NoteListDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/note/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200NoteListDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/note/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200NoteListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200NoteListDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200NoteListDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200NoteListGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/note/list operation.
//
// Retrieve a list of notes based on a system ID and page name.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/note/list
func (c *Client) GatewaySystem20Census20Core20API200NoteListGet(ctx context.Context, params GatewaySystem20Census20Core20API200NoteListGetParams) (GatewaySystem20Census20Core20API200NoteListGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200NoteListGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200NoteListGet(ctx context.Context, params GatewaySystem20Census20Core20API200NoteListGetParams) (res GatewaySystem20Census20Core20API200NoteListGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/note/list"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200NoteListGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/note/list"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.PageName))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200NoteListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200NoteListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200NoteListGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200NotePost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/note operation.
//
// Add one or more notes to a system in the census database. Notes are associated with specific pages
// within a system and can include optional email notifications to reviewers and respondents. Each
// note is automatically timestamped upon creation.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/note
func (c *Client) GatewaySystem20Census20Core20API200NotePost(ctx context.Context, request *GatewaySystem20Census20Core20API200NotePostReq) (GatewaySystem20Census20Core20API200NotePostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200NotePost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200NotePost(ctx context.Context, request *GatewaySystem20Census20Core20API200NotePostReq) (res GatewaySystem20Census20Core20API200NotePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/note"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200NotePostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/note"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200NotePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200NotePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200NotePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200NotePut invokes PUT /gateway/System%20Census%20Core%20API/2.0.0/note operation.
//
// Update a specific note by its ID.
//
// PUT /gateway/System%20Census%20Core%20API/2.0.0/note
func (c *Client) GatewaySystem20Census20Core20API200NotePut(ctx context.Context, request *GatewaySystem20Census20Core20API200NotePutReq, params GatewaySystem20Census20Core20API200NotePutParams) (GatewaySystem20Census20Core20API200NotePutRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200NotePut(ctx, request, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200NotePut(ctx context.Context, request *GatewaySystem20Census20Core20API200NotePutReq, params GatewaySystem20Census20Core20API200NotePutParams) (res GatewaySystem20Census20Core20API200NotePutRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/note"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200NotePutOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/note"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200NotePutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200NotePutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200NotePutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200NotePutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageBusinessOwnerGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/businessOwner operation.
//
// Get business owner basic information for a system by system ID.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/businessOwner
func (c *Client) GatewaySystem20Census20Core20API200PageBusinessOwnerGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageBusinessOwnerGetParams) (GatewaySystem20Census20Core20API200PageBusinessOwnerGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageBusinessOwnerGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageBusinessOwnerGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageBusinessOwnerGetParams) (res GatewaySystem20Census20Core20API200PageBusinessOwnerGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/businessOwner"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageBusinessOwnerGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/businessOwner"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageBusinessOwnerGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageBusinessOwnerGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageBusinessOwnerGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageDataCentersGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters operation.
//
// Retrieves the deployment information including the data center or cloud service provider
// information, for given System ID.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters
func (c *Client) GatewaySystem20Census20Core20API200PageDataCentersGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageDataCentersGetParams) (GatewaySystem20Census20Core20API200PageDataCentersGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageDataCentersGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageDataCentersGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageDataCentersGetParams) (res GatewaySystem20Census20Core20API200PageDataCentersGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageDataCentersGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.State)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Status)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Type)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageDataCentersGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageDataCentersGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageDataCentersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageDataCentersPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters operation.
//
// Add, update, or delete system data center/deployment information. Supports full CRUD operations
// for deployment relationships and system-level cloud migration settings.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters
func (c *Client) GatewaySystem20Census20Core20API200PageDataCentersPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataCentersPostReq) (GatewaySystem20Census20Core20API200PageDataCentersPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageDataCentersPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageDataCentersPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataCentersPostReq) (res GatewaySystem20Census20Core20API200PageDataCentersPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageDataCentersPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/dataCenters"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200PageDataCentersPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageDataCentersPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageDataCentersPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageDataCentersPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageDataExchangeGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange operation.
//
// Retrieve data exchange information by system ID and optionally version.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange
func (c *Client) GatewaySystem20Census20Core20API200PageDataExchangeGet(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataExchangeGetReq, params GatewaySystem20Census20Core20API200PageDataExchangeGetParams) (GatewaySystem20Census20Core20API200PageDataExchangeGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageDataExchangeGet(ctx, request, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageDataExchangeGet(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataExchangeGetReq, params GatewaySystem20Census20Core20API200PageDataExchangeGetParams) (res GatewaySystem20Census20Core20API200PageDataExchangeGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageDataExchangeGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Version.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200PageDataExchangeGetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageDataExchangeGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageDataExchangeGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageDataExchangeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageDataExchangePost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange operation.
//
// Add or update data exchange information for a system. A data exchange can be between two CMS IT
// systems or between a CMS system and a non-CMS stakeholder.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange
func (c *Client) GatewaySystem20Census20Core20API200PageDataExchangePost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataExchangePostReq) (GatewaySystem20Census20Core20API200PageDataExchangePostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageDataExchangePost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageDataExchangePost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageDataExchangePostReq) (res GatewaySystem20Census20Core20API200PageDataExchangePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageDataExchangePostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/dataExchange"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200PageDataExchangePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageDataExchangePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageDataExchangePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageDataExchangePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageSoftwareProductsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/softwareProducts operation.
//
// Get software products list for a system by system ID.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/softwareProducts
func (c *Client) GatewaySystem20Census20Core20API200PageSoftwareProductsGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSoftwareProductsGetParams) (GatewaySystem20Census20Core20API200PageSoftwareProductsGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageSoftwareProductsGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageSoftwareProductsGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSoftwareProductsGetParams) (res GatewaySystem20Census20Core20API200PageSoftwareProductsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/softwareProducts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageSoftwareProductsGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/softwareProducts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageSoftwareProductsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageSoftwareProductsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageSoftwareProductsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageSystemDataGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemData operation.
//
// Retrieves system data page census information for a given system or all systems.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemData
func (c *Client) GatewaySystem20Census20Core20API200PageSystemDataGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSystemDataGetParams) (GatewaySystem20Census20Core20API200PageSystemDataGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageSystemDataGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageSystemDataGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSystemDataGetParams) (res GatewaySystem20Census20Core20API200PageSystemDataGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/systemData"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageSystemDataGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/systemData"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemGUID" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemGUID",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SystemGUID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.SystemId.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageSystemDataGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageSystemDataGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageSystemDataGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageSystemDataPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/systemData operation.
//
// Adds or updates system data page census information for a given system.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/page/systemData
func (c *Client) GatewaySystem20Census20Core20API200PageSystemDataPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageSystemDataPostReq) (GatewaySystem20Census20Core20API200PageSystemDataPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageSystemDataPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageSystemDataPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageSystemDataPostReq) (res GatewaySystem20Census20Core20API200PageSystemDataPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/systemData"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageSystemDataPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/systemData"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200PageSystemDataPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageSystemDataPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageSystemDataPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageSystemDataPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageSystemMaintainerGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemMaintainer operation.
//
// Retrieve system maintainer information for a given system ID.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemMaintainer
func (c *Client) GatewaySystem20Census20Core20API200PageSystemMaintainerGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSystemMaintainerGetParams) (GatewaySystem20Census20Core20API200PageSystemMaintainerGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageSystemMaintainerGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageSystemMaintainerGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageSystemMaintainerGetParams) (res GatewaySystem20Census20Core20API200PageSystemMaintainerGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/systemMaintainer"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageSystemMaintainerGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/systemMaintainer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageSystemMaintainerGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageSystemMaintainerGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageSystemMaintainerGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageSystemsListGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemsList operation.
//
// Retrieve a list of all systems in the System Census.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/systemsList
func (c *Client) GatewaySystem20Census20Core20API200PageSystemsListGet(ctx context.Context) (GatewaySystem20Census20Core20API200PageSystemsListGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageSystemsListGet(ctx)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageSystemsListGet(ctx context.Context) (res GatewaySystem20Census20Core20API200PageSystemsListGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/systemsList"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageSystemsListGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/systemsList"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageSystemsListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageSystemsListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageSystemsListGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageUrlsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/page/Urls operation.
//
// Retrieve the URLs that are used to access the system, for a given System ID.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/page/Urls
func (c *Client) GatewaySystem20Census20Core20API200PageUrlsGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageUrlsGetParams) (GatewaySystem20Census20Core20API200PageUrlsGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageUrlsGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageUrlsGet(ctx context.Context, params GatewaySystem20Census20Core20API200PageUrlsGetParams) (res GatewaySystem20Census20Core20API200PageUrlsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/Urls"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageUrlsGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/Urls"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageUrlsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageUrlsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageUrlsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PageUrlsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/page/Urls operation.
//
// Creates, updates, or deletes URL records associated with a system.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/page/Urls
func (c *Client) GatewaySystem20Census20Core20API200PageUrlsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageUrlsPostReq) (GatewaySystem20Census20Core20API200PageUrlsPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PageUrlsPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PageUrlsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200PageUrlsPostReq) (res GatewaySystem20Census20Core20API200PageUrlsPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/page/Urls"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PageUrlsPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/page/Urls"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200PageUrlsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PageUrlsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PageUrlsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PageUrlsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200PersonGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/person operation.
//
// Retrieve a list of persons from LDAP based on query criteria. At least one parameter must be
// provided for the search.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/person
func (c *Client) GatewaySystem20Census20Core20API200PersonGet(ctx context.Context, request *GatewaySystem20Census20Core20API200PersonGetReq, params GatewaySystem20Census20Core20API200PersonGetParams) (GatewaySystem20Census20Core20API200PersonGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200PersonGet(ctx, request, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200PersonGet(ctx context.Context, request *GatewaySystem20Census20Core20API200PersonGetReq, params GatewaySystem20Census20Core20API200PersonGetParams) (res GatewaySystem20Census20Core20API200PersonGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/person"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200PersonGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/person"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "userName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "userName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UserName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "firstName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "firstName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FirstName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "lastName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "lastName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.LastName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "phone" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "phone",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Phone.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "email" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "email",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Email.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200PersonGetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200PersonGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200PersonGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200PersonGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SoftwareProductsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/softwareProducts operation.
//
// Add or update software product details and system-level API/AI information.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/softwareProducts
func (c *Client) GatewaySystem20Census20Core20API200SoftwareProductsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SoftwareProductsPostReq) (GatewaySystem20Census20Core20API200SoftwareProductsPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SoftwareProductsPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SoftwareProductsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SoftwareProductsPostReq) (res GatewaySystem20Census20Core20API200SoftwareProductsPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/softwareProducts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SoftwareProductsPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/softwareProducts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200SoftwareProductsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SoftwareProductsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SoftwareProductsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SoftwareProductsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200StatusDelete invokes DELETE /gateway/System%20Census%20Core%20API/2.0.0/status operation.
//
// Deletes one or more system status records by their IDs.
//
// DELETE /gateway/System%20Census%20Core%20API/2.0.0/status
func (c *Client) GatewaySystem20Census20Core20API200StatusDelete(ctx context.Context, params GatewaySystem20Census20Core20API200StatusDeleteParams) (GatewaySystem20Census20Core20API200StatusDeleteRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200StatusDelete(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200StatusDelete(ctx context.Context, params GatewaySystem20Census20Core20API200StatusDeleteParams) (res GatewaySystem20Census20Core20API200StatusDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200StatusDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "soft" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "soft",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Soft.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200StatusDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200StatusDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200StatusDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200StatusGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/status operation.
//
// Retrieves system census status information for systems and pages.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/status
func (c *Client) GatewaySystem20Census20Core20API200StatusGet(ctx context.Context, params GatewaySystem20Census20Core20API200StatusGetParams) (GatewaySystem20Census20Core20API200StatusGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200StatusGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200StatusGet(ctx context.Context, params GatewaySystem20Census20Core20API200StatusGetParams) (res GatewaySystem20Census20Core20API200StatusGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200StatusGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "summarize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "summarize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Summarize.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200StatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200StatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200StatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200StatusPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/status operation.
//
// Adds or updates a list of system status records.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/status
func (c *Client) GatewaySystem20Census20Core20API200StatusPost(ctx context.Context, request *GatewaySystem20Census20Core20API200StatusPostReq) (GatewaySystem20Census20Core20API200StatusPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200StatusPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200StatusPost(ctx context.Context, request *GatewaySystem20Census20Core20API200StatusPostReq) (res GatewaySystem20Census20Core20API200StatusPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200StatusPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200StatusPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200StatusPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200StatusPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200StatusPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SystemAiUseGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use operation.
//
// Retrieves AI Use census data for a specific system by its GUID.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use
func (c *Client) GatewaySystem20Census20Core20API200SystemAiUseGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemAiUseGetParams) (GatewaySystem20Census20Core20API200SystemAiUseGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SystemAiUseGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SystemAiUseGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemAiUseGetParams) (res GatewaySystem20Census20Core20API200SystemAiUseGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/system/ai-use"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SystemAiUseGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/system/ai-use"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SystemAiUseGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SystemAiUseGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SystemAiUseGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SystemAiUsePost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use operation.
//
// Updates AI Use census information for a given system.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/system/ai-use
func (c *Client) GatewaySystem20Census20Core20API200SystemAiUsePost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemAiUsePostReq) (GatewaySystem20Census20Core20API200SystemAiUsePostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SystemAiUsePost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SystemAiUsePost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemAiUsePostReq) (res GatewaySystem20Census20Core20API200SystemAiUsePostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/system/ai-use"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SystemAiUsePostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/system/ai-use"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200SystemAiUsePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SystemAiUsePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SystemAiUsePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SystemAiUsePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SystemComponentsGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/systemComponents operation.
//
// Retrieves a list of sub-systems or components that make up the overall system. If no components
// are found, an empty list is returned. This endpoint aligns with the Webmethods
// `pageSystemComponentsFind` service.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/systemComponents
func (c *Client) GatewaySystem20Census20Core20API200SystemComponentsGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemComponentsGetParams) (GatewaySystem20Census20Core20API200SystemComponentsGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SystemComponentsGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SystemComponentsGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemComponentsGetParams) (res GatewaySystem20Census20Core20API200SystemComponentsGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/systemComponents"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SystemComponentsGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/systemComponents"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SystemComponentsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SystemComponentsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SystemComponentsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SystemComponentsPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/systemComponents operation.
//
// Add, update or delete system components for a given system.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/systemComponents
func (c *Client) GatewaySystem20Census20Core20API200SystemComponentsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemComponentsPostReq) (GatewaySystem20Census20Core20API200SystemComponentsPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SystemComponentsPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SystemComponentsPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemComponentsPostReq) (res GatewaySystem20Census20Core20API200SystemComponentsPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/systemComponents"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SystemComponentsPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/systemComponents"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200SystemComponentsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SystemComponentsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SystemComponentsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SystemComponentsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SystemMaintainerPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/systemMaintainer operation.
//
// Adds or updates system maintainer details for a given system.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/systemMaintainer
func (c *Client) GatewaySystem20Census20Core20API200SystemMaintainerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemMaintainerPostReq) (GatewaySystem20Census20Core20API200SystemMaintainerPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SystemMaintainerPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SystemMaintainerPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemMaintainerPostReq) (res GatewaySystem20Census20Core20API200SystemMaintainerPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/systemMaintainer"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SystemMaintainerPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/systemMaintainer"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200SystemMaintainerPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SystemMaintainerPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SystemMaintainerPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SystemMaintainerPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SystemPropertyGet invokes GET /gateway/System%20Census%20Core%20API/2.0.0/systemProperty operation.
//
// Retrieve a specific system property value for a given system ID and property name.
//
// GET /gateway/System%20Census%20Core%20API/2.0.0/systemProperty
func (c *Client) GatewaySystem20Census20Core20API200SystemPropertyGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemPropertyGetParams) (GatewaySystem20Census20Core20API200SystemPropertyGetRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SystemPropertyGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SystemPropertyGet(ctx context.Context, params GatewaySystem20Census20Core20API200SystemPropertyGetParams) (res GatewaySystem20Census20Core20API200SystemPropertyGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/systemProperty"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SystemPropertyGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/systemProperty"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "systemId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "systemId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SystemId))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "propertyName" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "propertyName",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.PropertyName))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SystemPropertyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SystemPropertyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SystemPropertyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewaySystem20Census20Core20API200SystemPropertyPost invokes POST /gateway/System%20Census%20Core%20API/2.0.0/systemProperty operation.
//
// Add or update a system property value for a given system ID and property name.
//
// POST /gateway/System%20Census%20Core%20API/2.0.0/systemProperty
func (c *Client) GatewaySystem20Census20Core20API200SystemPropertyPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemPropertyPostReq) (GatewaySystem20Census20Core20API200SystemPropertyPostRes, error) {
	res, err := c.sendGatewaySystem20Census20Core20API200SystemPropertyPost(ctx, request)
	return res, err
}

func (c *Client) sendGatewaySystem20Census20Core20API200SystemPropertyPost(ctx context.Context, request *GatewaySystem20Census20Core20API200SystemPropertyPostReq) (res GatewaySystem20Census20Core20API200SystemPropertyPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/gateway/System%20Census%20Core%20API/2.0.0/systemProperty"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewaySystem20Census20Core20API200SystemPropertyPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/System%20Census%20Core%20API/2.0.0/systemProperty"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGatewaySystem20Census20Core20API200SystemPropertyPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewaySystem20Census20Core20API200SystemPropertyPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewaySystem20Census20Core20API200SystemPropertyPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewaySystem20Census20Core20API200SystemPropertyPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayTechnopedia10SoftwareExtendedGet invokes GET /gateway/Technopedia/1.0/softwareExtended operation.
//
// Retrieve software product information from Technopedia database. Supports multiple query modes:
// exact match by manufacturer, product name, version, and edition (update=true), fuzzy search with
// LIKE matching (update=false), or lookup by ID. All filter parameters are optional and can be
// combined.
//
// GET /gateway/Technopedia/1.0/softwareExtended
func (c *Client) GatewayTechnopedia10SoftwareExtendedGet(ctx context.Context, params GatewayTechnopedia10SoftwareExtendedGetParams) (GatewayTechnopedia10SoftwareExtendedGetRes, error) {
	res, err := c.sendGatewayTechnopedia10SoftwareExtendedGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayTechnopedia10SoftwareExtendedGet(ctx context.Context, params GatewayTechnopedia10SoftwareExtendedGetParams) (res GatewayTechnopedia10SoftwareExtendedGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/Technopedia/1.0/softwareExtended"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayTechnopedia10SoftwareExtendedGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/gateway/Technopedia/1.0/softwareExtended"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "product_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "product_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProductName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "product_name_operation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "product_name_operation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProductNameOperation.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vendor" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vendor",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Vendor.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "vendor_operation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "vendor_operation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VendorOperation.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Version.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version_operation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version_operation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionOperation.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "edition" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "edition",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Edition.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "edition_operation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "edition_operation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EditionOperation.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "summary" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "summary",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Summary)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "update" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "update",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Update)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "fetch_limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "fetch_limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FetchLimit.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayTechnopedia10SoftwareExtendedGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayTechnopedia10SoftwareExtendedGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayTechnopedia10SoftwareExtendedGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GatewayTechnopedia10SoftwareExtendedIDGet invokes GET /gateway/Technopedia/1.0/softwareExtended/{id} operation.
//
// Retrieve extended software information by ID from Technopedia database.
//
// GET /gateway/Technopedia/1.0/softwareExtended/{id}
func (c *Client) GatewayTechnopedia10SoftwareExtendedIDGet(ctx context.Context, params GatewayTechnopedia10SoftwareExtendedIDGetParams) (GatewayTechnopedia10SoftwareExtendedIDGetRes, error) {
	res, err := c.sendGatewayTechnopedia10SoftwareExtendedIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGatewayTechnopedia10SoftwareExtendedIDGet(ctx context.Context, params GatewayTechnopedia10SoftwareExtendedIDGetParams) (res GatewayTechnopedia10SoftwareExtendedIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/gateway/Technopedia/1.0/softwareExtended/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GatewayTechnopedia10SoftwareExtendedIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/gateway/Technopedia/1.0/softwareExtended/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, GatewayTechnopedia10SoftwareExtendedIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, GatewayTechnopedia10SoftwareExtendedIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGatewayTechnopedia10SoftwareExtendedIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthGet invokes GET /health operation.
//
// Health check endpoint.
//
// GET /health
func (c *Client) HealthGet(ctx context.Context) (*HealthGetOK, error) {
	res, err := c.sendHealthGet(ctx)
	return res, err
}

func (c *Client) sendHealthGet(ctx context.Context) (res *HealthGetOK, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/health"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HealthGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, HealthGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, HealthGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeHealthGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SparxIDDelete invokes DELETE /sparx/{id} operation.
//
// Delete SparxEA object by ID.
//
// DELETE /sparx/{id}
func (c *Client) SparxIDDelete(ctx context.Context, params SparxIDDeleteParams) (SparxIDDeleteRes, error) {
	res, err := c.sendSparxIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendSparxIDDelete(ctx context.Context, params SparxIDDeleteParams) (res SparxIDDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/sparx/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SparxIDDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/sparx/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, SparxIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, SparxIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSparxIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SparxIDGet invokes GET /sparx/{id} operation.
//
// Get SparxEA object by ID.
//
// GET /sparx/{id}
func (c *Client) SparxIDGet(ctx context.Context, params SparxIDGetParams) (SparxIDGetRes, error) {
	res, err := c.sendSparxIDGet(ctx, params)
	return res, err
}

func (c *Client) sendSparxIDGet(ctx context.Context, params SparxIDGetParams) (res SparxIDGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/sparx/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SparxIDGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/sparx/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, SparxIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, SparxIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSparxIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SparxPost invokes POST /sparx operation.
//
// Create a new SparxEA object.
//
// POST /sparx
func (c *Client) SparxPost(ctx context.Context, request *SparxPostReq) (SparxPostRes, error) {
	res, err := c.sendSparxPost(ctx, request)
	return res, err
}

func (c *Client) sendSparxPost(ctx context.Context, request *SparxPostReq) (res SparxPostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/sparx"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SparxPostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sparx"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSparxPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:GatewayApikey"
			switch err := c.securityGatewayApikey(ctx, SparxPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"GatewayApikey\"")
			}
		}
		{
			stage = "Security:JWTKey"
			switch err := c.securityJWTKey(ctx, SparxPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"JWTKey\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSparxPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SwaggerUIGet invokes GET /swagger-ui operation.
//
// Loads the Swagger UI tool.
//
// GET /swagger-ui
func (c *Client) SwaggerUIGet(ctx context.Context) (SwaggerUIGetRes, error) {
	res, err := c.sendSwaggerUIGet(ctx)
	return res, err
}

func (c *Client) sendSwaggerUIGet(ctx context.Context) (res SwaggerUIGetRes, err error) {
	otelAttrs := []attribute.KeyValue{
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/swagger-ui"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SwaggerUIGetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/swagger-ui"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeSwaggerUIGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
